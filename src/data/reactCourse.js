export const reactCourseData = {
  title: "Основи React",
  description: "Вивчіть React від основ до просунутих концепцій. Комплексний курс, який навчить вас створювати сучасні інтерактивні користувацькі інтерфейси.",
  level: "Від початкового до просунутого",
  duration: "~20 годин",
  prerequisites: "JavaScript ES6+, HTML, CSS",
  certificate: "Доступний після завершення",
  topics: [
    {
      id: 1,
      title: "Введення в React та Virtual DOM",
      difficulty: "Початковий",
      duration: "40 хв",
      completed: true,
      description: "Дізнайтеся основи React, концепцію Virtual DOM та переваги використання цієї бібліотеки.",
      learningPoints: [
        "Що таке React та для чого він використовується",
        "Virtual DOM: основи та переваги",
        "Процес reconciliation",
        "Налаштування проекту з Create React App",
        "Babel та компіляція JSX"
      ],
      theory: {
        "Що таке React": "React.js - це JavaScript бібліотека з відкритим вихідним кодом для розробки інтерфейсів користувача. Компонент React створюється дуже просто, оскільки він використовує JSX - опціональне розширення синтаксису JavaScript, яке дозволяє комбінувати HTML із JavaScript.",
        "Virtual DOM": "Virtual DOM - це ідея про створення віртуального представлення структури дерева об'єктів DOM у пам'яті. Основні переваги: покращення швидкості відображення змін та спрощення взаємодії з подіями. DOM (Document Object Model) — це структурне представлення HTML-документа, яке браузер створює після завантаження сторінки.",
        "Reconciliation": "Reconciliation - це процес порівняння попереднього та поточного стану Virtual DOM для визначення різниці між ними. Після визначення змін React визначає оптимальний шлях оновлення реального DOM, зменшуючи навантаження на браузер. React використовує алгоритми 'diffing' для визначення мінімальних змін, які необхідно внести в DOM.",
        "Create React App": "Переваги: швидкий старт, стандартна структура, автоматичне перезавантаження, вбудована оптимізація, легкість оновлення. Недоліки: обмежена конфігурація, розмір конфігураційних файлів, неавтоматичні опції, залежність від npm, вбудований код.",
        "Babel": "Babel — це компілятор JavaScript, який перетворює останній JavaScript, як-от ES6, ES7, у звичайний старий JavaScript ES5, який розуміє більшість браузерів. Це дозволяє використовувати сучасні можливості JavaScript та JSX."
      }
    },
    {
      id: 2,
      title: "JSX та основи синтаксису",
      difficulty: "Початковий",
      duration: "35 хв",
      completed: false,
      description: "Опануйте JSX - розширення синтаксису JavaScript для опису UI компонентів.",
      learningPoints: [
        "Що таке JSX та його основні концепції",
        "Вбудовані вирази JavaScript в JSX",
        "Робота з класами та подіями в JSX",
        "Відмінності JSX від HTML",
        "Атрибут key при рендері списків"
      ],
      theory: {
        "JSX основи": "JSX (JavaScript XML) - це розширення синтаксису JavaScript, яке надає можливість описувати структуру UI, схожу на XML чи HTML. JSX - це суміш JavaScript та HTML. Це ключовий елемент в React, який дозволяє описувати компоненти та їхній вигляд прямо в коді JavaScript.",
        "Основні концепції JSX": "• Синтаксис схожий на HTML • Вбудовані вирази JavaScript • Компоненти в JSX • Класи та стилі",
        "Класи та події": "Робота з класами: використовуються атрибути className для встановлення класів елементів в JSX. Динамічні класи: можемо використовувати JavaScript в фігурних дужках, щоб встановлювати класи динамічно, залежно від умов. Робота з подіями: для обробки подій використовуємо атрибути, подібні до HTML, такі як onClick, onChange і так далі.",
        "JSX правила": "JSX повинен мати один кореневий елемент, атрибути пишуться в camelCase, самозакриваючі теги потребують слеша.",
        "Атрибут key": "Кожен елемент списку повинен мати унікальний key, який дозволяє React правильно ідентифікувати його серед інших елементів. Він допомагає React визначити, які елементи були додані, видалені або змінені."
      }
    },
    {
      id: 3,
      title: "Компоненти: функціональні та класові",
      difficulty: "Початковий",
      duration: "45 хв",
      completed: false,
      description: "Розуміння різних типів компонентів у React та їх основних відмінностей.",
      learningPoints: [
        "Функціональні компоненти",
        "Класові компоненти",
        "Основні відмінності між типами компонентів",
        "Коли використовувати кожен тип",
        "Декомпозиція компонентів"
      ],
      theory: {
        "Функціональні компоненти": "Function component - це прості JavaScript функції, які приймають props та повертають React-елемент. Найпростіше оголосити React-компонент як функцію. Ця функція і є компонентом, тому вона повертає React-елемент. Такі компоненти називають «функціональними», оскільки вони є функціями.",
        "Класові компоненти": "Class component - це класи, які розширюють React.Component і мають внутрішній стан через this.state та доступ до методів життєвого циклу, таких як componentDidMount та componentDidUpdate.",
        "Основні відмінності": "1. Синтаксис: function components мають простіший синтаксис, class components вимагають використання класів та розширення React.Component 2. Стан: function components використовують хуки для стану, class components мають внутрішній стан, доступний через this.state 3. Життєвий цикл: class components мають різні методи життєвого циклу, function components не мали їх до версії 16.8 4. Використання хуків: function components з введенням хуків (useState, useEffect) можуть використовувати стан та життєвий цикл, class components залежить від методів життєвого циклу для управління станом та діями",
        "Компоненти багаторазового використання": "React дозволяє використовувати компоненти повторно, розроблені в інших додатках. Готові бібліотеки: Material UI, Reactstrap, DevExpress, Ant Design.",
        "Декомпозиція компонентів": "Компоненти можуть посилатися на інші компоненти у поверненому ними дереві. Це дозволяє нам використовувати той самий компонент кілька разів та створювати складні UI з простих частин."
      }
    },
    {
      id: 4,
      title: "Props та State",
      difficulty: "Початковий",
      duration: "50 хв",
      completed: false,
      description: "Вивчіть основи передачі даних між компонентами та управління внутрішнім станом.",
      learningPoints: [
        "Props: передача та використання",
        "State: створення та оновлення",
        "Правила роботи зі станом",
        "Односпрямований потік даних",
        "Різниця між станом та пропсами"
      ],
      theory: {
        "Props": "Props (властивості) - передаються в компонент і служать як параметри виклику функції. Props можна лише читати! Зміна Props призводить до повторного виклику методу render та як наслідок перемальовування компонента.",
        "State": "State - внутрішній стан компонента. Для його відображення у класовому компоненті потрібно: 1. У конструкторі створити у 'this' властивість 'state' як об'єкт з потрібними властивостями 2. У потрібному методі взяти властивість this.state",
        "Зміна стану": "Для зміни потрібно викликати метод this.setState. Цей метод додає зміну у стані компонента. Також він вказує на React, що компонента і його дочірні елементи повинні бути повторно відрендеровані з оновленим станом.",
        "Правила стану": "1. Не змінюйте стан безпосередньо 2. Оновлення стану об'єднуються 3. Оновлення стану можуть бути асинхронними",
        "Різниця між станом та пропсами": "Основна різниця полягає в тому, що стан використовується для управління даними, які можуть змінюватися в самому компоненті, тоді як пропси використовуються для передачі даних в компонент ззовні і вони є незмінними для компонента."
      }
    },
    {
      id: 5,
      title: "Життєвий цикл компонентів",
      difficulty: "Середній",
      duration: "55 хв",
      completed: false,
      description: "Розуміння етапів життя компонентів та методів життєвого циклу.",
      learningPoints: [
        "Три етапи життєвого циклу",
        "Основні методи життєвого циклу",
        "Монтування, оновлення, розмонтування",
        "Практичне використання методів",
        "Фази рендерингу"
      ],
      theory: {
        "Життєвий цикл": "Життєвий цикл компонента — це послідовність етапів, які проходить компонент від моменту створення до видалення з DOM. Класовий компонент за час свого життя проходить 3 етапи.",
        "Три етапи": "1. Монтування - це перший рендер та вставка результату рендеру в DOM 2. Оновлення - це всі наступні рендери та оновлення раніше вставленого в DOM 3. Розмонтування - це видалення раніше вставленого в DOM",
        "Фази": "Кожна фаза може мати до 3 фаз: • Render - впливає на рендер, може бути призупинено, перервано або перезапущено самим React • Pre-commit - можна читати DOM до його оновлення • Commit - можна робити щось після оновлення DOM: ручна зміна DOM, запити до сервера, оновлення стану тощо",
        "Основні методи": "Методи життєвого циклу - це функції, що настроюються, які виконуються на різних станах життя компонента. Монтування: constructor(), render(), componentDidMount() Оновлення: componentDidUpdate(), render() Розмонтування: componentWillUnmount()",
        "Детальний опис методів": "constructor() - викликається до того, як компонент буде вмонтовано, потрібно викликати super(props). render() - єдиний обов'язковий метод у класовому компоненті. componentDidMount() - викликається відразу після монтування, підходить для налаштування підписок. componentDidUpdate() - викликається після оновлення компонента. componentWillUnmount() - викликається перед розмонтуванням, виконується скидання: скасування таймерів, мережевих запитів та передплат."
      }
    },
    {
      id: 6,
      title: "React Hooks: useState та useEffect",
      difficulty: "Середній",
      duration: "60 хв",
      completed: false,
      description: "Освойте основні хуки React для управління станом та побічними ефектами.",
      learningPoints: [
        "Що таке хуки та їх переваги",
        "useState для управління станом",
        "useEffect для побічних ефектів",
        "Правила використання хуків",
        "Кастомні хуки"
      ],
      theory: {
        "Хуки": "Хуки - це функції, які додають стан та інші можливості в функціональні компоненти. Назва починається з 'use'. Хуки не можна використовувати за умовою. Кожен хук щось повертає. Кастомні хуки - це хуки які ми самі написали.",
        "Проблеми які вирішують хуки": "1. Спільний код логіки компонентів - дозволяють витягувати та використовувати спільний код логіки між компонентами 2. Складна логіка стану та ефектів - дозволяють розбити складну логіку на менші та керовані частини 3. Відсутність повноцінного стану та ефектів в функціональних компонентах 4. Затримка рендерингу та витрати пам'яті - дозволяють оптимізувати рендеринг та управління пам'яттю 5. Спільне використання стану та логіки між компонентами",
        "useState": "Хук useState дозволяє додавати стан до функціональних компонентів. Додає зміну стану в компонент. Дозволяє використовувати стан в функціональних компонентах.",
        "useEffect": "Хук useEffect використовується для виконання побічних ефектів (запити до API, маніпуляції з DOM) у функціональних компонентах. Виконує код після рендеру компонента. Являє собою сукупність методів: componentDidMount, componentWillUpdate, componentWillUnmount.",
        "Правила хуків": "1. Використовувати хуки тільки в функціональних компонентах 2. Використовувати хуки лише на верхньому рівні компонента (не вкладати в умови, цикли чи інші блоки) 3. Використовувати хуки лише в компонентах React 4. Дотримуватися одного порядку виклику хуків 5. Називайте хуки згідно правилам іменування",
        "Кастомні хуки": "Кастомні хуки (Custom Hooks) - це функції, які мають префікс 'use' та використовуються для відділення та перевиконання логіки між різними компонентами. Переваги: повторне використання логіки, читабельність та підтримуваність коду, вдосконалення декларативності."
      }
    },
    {
      id: 7,
      title: "Просунуті хуки: useContext, useReducer, useMemo",
      difficulty: "Просунутий",
      duration: "65 хв",
      completed: false,
      description: "Вивчіть просунуті хуки для складного управління станом та оптимізації.",
      learningPoints: [
        "useContext для передачі даних",
        "useReducer для складного стану",
        "useMemo та useCallback для оптимізації",
        "useRef для роботи з DOM"
      ],
      theory: {
        "useContext": "Хук useContext дозволяє отримати значення з контексту, заміняючи необхідність передавати пропси через кілька рівнів компонентів.",
        "useReducer": "Хук useReducer дозволяє керувати станом компонента за допомогою функцій редуктора. Корисний для складного стану.",
        "useMemo та useCallback": "useMemo - дозволяє мемоізувати результат виклику функції та зберігати його між рендерами компонента. Використовується, коли необхідно запам'ятовувати результат обчислення деякого значення. useCallback - схожий на useMemo, але використовується для мемоізації функцій, зокрема, колбеків. Використовується, коли функція передається дочірнім компонентам і може створюватися знову при кожному рендерингу.",
        "useRef": "Хук useRef допомагає зберігати значення між рендерами компонента, але не викликає повторний рендер при зміні цього значення. React-посилання - це механізм для доступу до DOM-елементів або компонентів безпосередньо."
      }
    },
    {
      id: 8,
      title: "Context API та глобальне управління станом",
      difficulty: "Просунутий",
      duration: "50 хв",
      completed: false,
      description: "Використання Context API для передачі даних через дерево компонентів.",
      learningPoints: [
        "Створення та використання Context",
        "Provider та Consumer",
        "Передача функцій через контекст",
        "Оптимізація контексту"
      ],
      theory: {
        "Context": "Context у React - це механізм, який дозволяє передавати дані вглиб без необхідності передавати пропси через кілька рівнів компонентів. Він дозволяє забезпечити глобальний доступ до певних значень у всьому додатку.",
        "Використання": "Контекст - це інструмент для передачі та отримання даних у React-додатках. • Використання загального контексту для значень, які є загальними для всього додатку • Передача функцій через контекст - можна передавати не тільки значення, але і функції • Оновлення контексту від подій",
        "Переваги": "Контекст дозволяє створювати більш гнучкі та масштабовані компоненти та полегшує управління станом у додатку.",
        "Оптимізація": "Розділяйте контексти на логічні частини та використовуйте мемоізацію для запобігання зайвих рендерів.",
        "Структура Context": "Контекст складається з 2 основних частин: 1. Provider - компонент, який надає дані контексту. Він обертає дочірні компоненти, які повинні мати доступ до цих даних 2. Consumer - компонент, який використовується для отримання даних контексту."
      }
    },
    {
      id: 9,
      title: "Маршрутизація з React Router",
      difficulty: "Середній",
      duration: "55 хв",
      completed: false,
      description: "Навігація в односторінкових додатках за допомогою React Router.",
      learningPoints: [
        "Налаштування React Router",
        "Основні компоненти: Router, Route, Link",
        "Параметри маршрутів",
        "Програмна навігація"
      ],
      theory: {
        "React Router": "React Router - це бібліотека для реалізації навігації в односторінкових додатках (SPA). Вона дозволяє створювати маршрути, що відображають різні компоненти на основі URL. React Router - це бібліотека для маршрутизації у реакті, яка дозволяє створювати односторінкові додатки з багатьма URL-шляхами.",
        "Основні елементи": "1. Browser Router - обгортка для всього додатка, яка дозволяє працювати з історією браузера та навігацією 2. Route - визначає шлях (URL) і компонент, який буде відображатися для цього шляху 3. Switch - забезпечує рендеринг лише одного компонента, що відповідає поточному маршруту 4. Link - дозволяє створювати клікабельні посилання для навігації без перезавантаження сторінки 5. NavLink - використовується для створення посилань, що підтримують активний стиль для поточного маршруту",
        "Маршрутизація": "Маршрутизація дозволяє керувати вмістом веб-додатка та визначити, який компонент відображати для конкретного шляху в URL. Це полегшує навігацію користувача. Основні завдання включають обробку маршрутів, передачу параметрів та забезпечення коректного відображення."
      }
    },
    {
      id: 10,
      title: "Оптимізація та просунуті паттерни",
      difficulty: "Просунутий",
      duration: "70 хв",
      completed: false,
      description: "Методи оптимізації React додатків та просунуті паттерни розробки.",
      learningPoints: [
        "React.memo та мемоізація",
        "Межі помилок (Error Boundaries)",
        "Відкладене завантаження (Lazy loading) та Suspense",
        "Власні хуки та паттерни",
        "PureComponent та оптимізація рендерингу"
      ],
      theory: {
        "Мемоізація": "Мемоізація - це техніка оптимізації, яка забезпечує збереження результатів викликів функцій та їх керування для подальшого використання. Вона дозволяє уникнути зайвих обчислень та зберегти результати для подальшого використання.",
        "React.memo": "React.memo - це функція в бібліотеці React, яка створює мемоізовану версію функціонального компонента. Її використовують для оптимізації рендерингу компонентів, які приймають сталі пропси та стан. Дозволяє уникнути зайвих ререндерів в React. React.memo може приймати 2 аргументи: компонент (обов'язковий) та функцію порівняння.",
        "Межі помилок": "Error Boundaries - це компоненти в React, які дозволяють ловити та обробляти помилки, які виникають в дочірніх компонентах під час рендерингу, в методах життєвого циклу або в конструкторі компонентів.",
        "Відкладене завантаження": "Дозволяє завантажувати компоненти тільки тоді, коли вони потрібні, що покращує початкову швидкість завантаження.",
        "PureComponent": "PureComponent - спеціальний тип компонента, який відмінний від звичайного компонента. PureComponent автоматично виконує перевірку на необхідність перерендерингу компонента перед викликом методу render(). Це досягається за допомогою перевірки попередніх та поточних значень пропсів і стану.",
        "Рендер": "Рендер - це процес, коли react створює або оновлює інтерфейс користувача (UI), грунтуючись на змінах у компоненті. Початковий рендер - це перше відображення компонента на сторінці. Повторний рендер - оновлення компонента, коли змінюється його state або props."
      }
    },
    {
      id: 11,
      title: "Просунуті концепції та паттерни",
      difficulty: "Просунутий",
      duration: "60 хв",
      completed: false,
      description: "Вивчіть просунуті концепції React: HOC, Portal, Fragment та інші паттерни.",
      learningPoints: [
        "Компонент вищого порядку (HOC)",
        "Portal та рендеринг поза ієрархією",
        "Fragment для групування елементів",
        "Керовані та некеровані компоненти",
        "Синтетичні події"
      ],
      theory: {
        "Компонент вищого порядку": "Компонент вищого порядку (HOC) - це функція, яка приймає компонент і повертає новий компонент. Його основна мета - розширити функціональність або перевикористати логіку в компонентах. Компонент вищого порядку не змінює вихідний компонент, але додає до нього додаткові властивості чи функціональність. Вони дозволяють виконувати такі дії, як логування, мемоізація, контейнеризація компонентів, обробка помилок.",
        "Portal": "Portal - дозволяють рендерити дочірні елементи в DOM-вузол, що знаходиться поза DOM-ієрархією батьківського компонента. Це дозволяє вставляти компоненти в будь-яку частину DOM, незалежно від його розташування в ієрархії компонентів.",
        "Fragment": "Fragment дозволяє формувати список дочірніх елементів, не створюючи зайвих вузлів в DOM. Children - це спеціальний пропс у реакті, який дозволяє передавати дочірні елементи в компонент.",
        "Керовані vs некеровані компоненти": "Керовані елементи: стан та значення керуються React, повний контроль над значеннями, підходить для валідації та дій. Некеровані елементи: стан не контролюється React, використовується для простих форм, менше коду для управління станом. Керовані елементи відповідають за кожну зміну у власному стані, що робить їх більш гнучкими і підходить для складних форм.",
        "Синтетичні події": "Синтетичні події є кросбраузерною обгорткою над нативними подіями браузера. Це означає, що React створює єдиний інтерфейс для обробки подій, який працює однаково у всіх браузерах.",
        "Умовний рендеринг": "Умовний рендерінг (Conditional Rendering) у React дозволяє рендерити різні компоненти або елементи в залежності від певних умов. Види: if/else, тернарний оператор, &&."
      }
    },
    {
      id: 12,
      title: "Redux та управління станом",
      difficulty: "Просунутий",
      duration: "75 хв",
      completed: false,
      description: "Освойте Redux для централізованого управління станом у великих додатках.",
      learningPoints: [
        "Основні принципи Redux",
        "Store, Actions та Reducers",
        "Інтеграція Redux з React",
        "Middleware та асинхронні дії",
        "Redux Toolkit"
      ],
      theory: {
        "Redux": "Redux - це потужна бібліотека для управління станом додатків в React. Вона дозволяє централізовано зберігати стан та ефективно його оновлювати.",
        "Три основні принципи Redux": "1. Єдине джерело правди - весь стан додатка зберігається в одному об'єкті - store 2. Стан програми доступний лише для читання - стан не можна змінювати напряму, а лише через action 3. Зміни можна внести лише за допомогою чистих функцій - стан оновлюється за допомогою функцій reducers, які приймають поточний стан і дію та повертають новий стан.",
        "Компоненти Redux": "Store - централізоване сховище стану додатка. Actions - об'єкти, які описують що сталося. Reducers - чисті функції, які визначають як стан змінюється у відповідь на дії.",
        "Переваги Redux": "Предсказуваність стану, централізоване управління, легке тестування, потужні інструменти розробки, підтримка time-travel debugging.",
        "Redux Toolkit": "Сучасний інструментарій для ефективної роботи з Redux, який спрощує налаштування store, написання reducers та обробку асинхронних дій."
      }
    },
    {
      id: 13,
      title: "Інтеграція з REST API та асинхронні операції",
      difficulty: "Просунутий",
      duration: "65 хв",
      completed: false,
      description: "Дізнайтеся, як інтегрувати React додатки з REST API та обробляти асинхронні операції.",
      learningPoints: [
        "Робота з fetch() та axios",
        "Обробка асинхронних запитів",
        "Управління станом завантаження",
        "Обробка помилок API",
        "Кешування та оптимізація запитів"
      ],
      theory: {
        "Інтеграція з REST API": "React додатки часто потребують взаємодії з серверними API для отримання та відправки даних. Основні методи для роботи з API.",
        "fetch()": "fetch() - це стандартний метод для виконання HTTP-запитів. Він повертає Promise, який вирішується у відповідь від сервера. Вбудований у браузери, не потребує додаткових бібліотек.",
        "axios": "axios() - це популярна бібліотека для HTTP-запитів, яка має зручний API та підтримує обробку запитів з перехоплювачами. Надає більше функцій порівняно з fetch().",
        "Надсилання даних": "Надсилання даних через POST - тут використовуються методи post та put для створення та оновлення ресурсів на сервері.",
        "Обробка асинхронних запитів": "Обробка асинхронних запитів через useEffect та useState - типовий паттерн для завантаження даних у функціональних компонентах.",
        "Управління станом": "Важливо правильно управляти станами завантаження (loading), успіху (success) та помилок (error) при роботі з API."
      }
    },
    {
      id: 14,
      title: "Робота з формами та валідація",
      difficulty: "Середній",
      duration: "55 хв",
      completed: false,
      description: "Опануйте створення та управління формами в React, включаючи валідацію даних.",
      learningPoints: [
        "Керовані та некеровані форми",
        "Бібліотека Formik",
        "Валідація даних",
        "Обробка подій форм",
        "Кастомні поля введення"
      ],
      theory: {
        "Робота з формами": "Форми є важливою частиною більшості веб-додатків. React надає гнучкі способи роботи з формами через керовані та некеровані компоненти.",
        "Formik": "Formik - це бібліотека для управління формами в React, яка надає зручні інструменти для обробки введених даних, валідації та управління станом форми. Основні функціональності: управління станом форми, обробка подій (onSubmit, onChange, onBlur), валідація, обробка форматування даних.",
        "Валідація": "Можливість використовувати вбудовані механізми валідації Formik або інтегрувати з бібліотеками валідації як Yup.",
        "Керовані форми": "У керованих формах значення полів зберігається у стані React компонента та оновлюється через обробники подій.",
        "Некеровані форми": "У некерованих формах значення полів зберігається у DOM, а доступ до них здійснюється через refs."
      }
    },
    {
      id: 15,
      title: "Тестування та налагодження React додатків",
      difficulty: "Просунутий",
      duration: "50 хв",
      completed: false,
      description: "Дізнайтеся про методи тестування та налагодження React компонентів.",
      learningPoints: [
        "Jest та React Testing Library",
        "Unit тестування компонентів",
        "Інтеграційне тестування",
        "Налагодження з React Developer Tools",
        "Логування та обробка помилок"
      ],
      theory: {
        "Тестування React": "Тестування є критично важливою частиною розробки надійних React додатків. Воно допомагає забезпечити якість коду та запобігти регресіям.",
        "Jest": "Jest - це фреймворк для тестування JavaScript, який часто використовується з React. Надає можливості для написання unit та інтеграційних тестів.",
        "React Testing Library": "Бібліотека для тестування React компонентів, яка фокусується на тестуванні поведінки компонентів з точки зору користувача.",
        "Unit тестування": "Тестування окремих компонентів в ізоляції для перевірки їх правильної роботи.",
        "Налагодження": "Логування - це потужний інструмент для відстеження помилок. React Developer Tools надає можливості для інспекції компонентів та їх стану.",
        "Обробка помилок": "Використання Error Boundaries та правильна обробка помилок для покращення користувацького досвіду."
      }
    }
  ]
};