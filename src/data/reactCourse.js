export const reactCourseData = {
  title: "Основи React",
  description: "Вивчіть React від основ до просунутих концепцій. Комплексний курс, який навчить вас створювати сучасні інтерактивні користувацькі інтерфейси.",
  level: "Від початкового до просунутого",
  duration: "~15 годин",
  prerequisites: "JavaScript ES6+, HTML, CSS",
  certificate: "Доступний після завершення",
  topics: [
    {
      id: 1,
      title: "Введення в React та Virtual DOM",
      difficulty: "Початковий",
      duration: "40 хв",
      completed: true,
      description: "Дізнайтеся основи React, концепцію Virtual DOM та переваги використання цієї бібліотеки.",
      learningPoints: [
        "Що таке React та для чого він використовується",
        "Virtual DOM: основи та переваги",
        "Процес reconciliation",
        "Налаштування проекту з Create React App"
      ],
      theory: {
        "Що таке React": "React.js - це JavaScript бібліотека з відкритим вихідним кодом для розробки інтерфейсів користувача. Компонент React створюється дуже просто, оскільки він використовує JSX.",
        "Virtual DOM": "Virtual DOM - це ідея про створення віртуального представлення структури дерева об'єктів DOM у пам'яті. Основні переваги: покращення швидкості відображення змін та спрощення взаємодії з подіями.",
        "Reconciliation": "Reconciliation - це процес порівняння попереднього та поточного стану Virtual DOM для визначення різниці між ними. React використовує алгоритми 'diffing' для визначення мінімальних змін у DOM.",
        "Create React App": "Переваги: швидкий старт, стандартна структура, автоматичне перезавантаження, вбудована оптимізація. Недоліки: обмежена конфігурація, розмір конфігураційних файлів, залежність від npm."
      }
    },
    {
      id: 2,
      title: "JSX та основи синтаксису",
      difficulty: "Початковий",
      duration: "35 хв",
      completed: false,
      description: "Опануйте JSX - розширення синтаксису JavaScript для опису UI компонентів.",
      learningPoints: [
        "Що таке JSX та його основні концепції",
        "Вбудовані вирази JavaScript в JSX",
        "Робота з класами та подіями в JSX",
        "Відмінності JSX від HTML"
      ],
      theory: {
        "JSX основи": "JSX (JavaScript XML) - це розширення синтаксису JavaScript, яке надає можливість описувати структуру UI, схожу на XML чи HTML. JSX - це суміш JavaScript та HTML.",
        "Основні концепції JSX": "• Синтаксис схожий на HTML • Вбудовані вирази JavaScript • Компоненти в JSX • Класи та стилі",
        "Класи та події": "Робота з класами: використовуються атрибути className для встановлення класів. Динамічні класи: використовуємо JavaScript в фігурних дужках. Робота з подіями: використовуємо атрибути onClick, onChange і так далі.",
        "JSX правила": "JSX повинен мати один кореневий елемент, атрибути пишуться в camelCase, самозакриваючі теги потребують слеша."
      }
    },
    {
      id: 3,
      title: "Компоненти: функціональні та класові",
      difficulty: "Початковий",
      duration: "45 хв",
      completed: false,
      description: "Розуміння різних типів компонентів у React та їх основних відмінностей.",
      learningPoints: [
        "Функціональні компоненти",
        "Класові компоненти",
        "Основні відмінності між типами компонентів",
        "Коли використовувати кожен тип"
      ],
      theory: {
        "Функціональні компоненти": "Функціональний компонент - це прості JavaScript функції, які приймають props та повертають React-елемент. Найпростіше оголосити React-компонент як функцію.",
        "Класові компоненти": "Класовий компонент - це класи, які розширюють React.Component і мають внутрішній стан через this.state та доступ до методів життєвого циклу.",
        "Основні відмінності": "1. Синтаксис: функціональні компоненти мають простіший синтаксис 2. Стан: функціональні компоненти використовують хуки 3. Життєвий цикл: класові компоненти мають методи життєвого циклу 4. Хуки: функціональні компоненти можуть використовувати хуки",
        "Компоненти багаторазового використання": "React дозволяє використовувати компоненти повторно. Готові бібліотеки: Material UI, Reactstrap, DevExpress, Ant Design."
      }
    },
    {
      id: 4,
      title: "Props та State",
      difficulty: "Початковий",
      duration: "50 хв",
      completed: false,
      description: "Вивчіть основи передачі даних між компонентами та управління внутрішнім станом.",
      learningPoints: [
        "Props: передача та використання",
        "State: створення та оновлення",
        "Правила роботи зі станом",
        "Односпрямований потік даних"
      ],
      theory: {
        "Props": "Props (властивості) - передаються в компонент і служать як параметри виклику функції. Props можна лише читати! Зміна Props призводить до повторного виклику методу render.",
        "State": "State - внутрішній стан компонента. Для його відображення у класовому компоненті потрібно: 1. У конструкторі створити this.state 2. У потрібному методі взяти this.state",
        "Зміна стану": "Для зміни потрібно викликати метод this.setState. Цей метод додає зміну у стані компонента та вказує React на необхідність повторного рендерингу.",
        "Правила стану": "1. Не змінюйте стан безпосередньо 2. Оновлення стану об'єднуються 3. Оновлення стану можуть бути асинхронними"
      }
    },
    {
      id: 5,
      title: "Життєвий цикл компонентів",
      difficulty: "Середній",
      duration: "55 хв",
      completed: false,
      description: "Розуміння етапів життя компонентів та методів життєвого циклу.",
      learningPoints: [
        "Три етапи життєвого циклу",
        "Основні методи життєвого циклу",
        "Монтування, оновлення, розмонтування",
        "Практичне використання методів"
      ],
      theory: {
        "Життєвий цикл": "Життєвий цикл компонента — це послідовність етапів, які проходить компонент від моменту створення до видалення з DOM.",
        "Три етапи": "1. Монтування - перший рендер та вставка в DOM 2. Оновлення - всі наступні рендери та оновлення DOM 3. Розмонтування - видалення з DOM",
        "Фази": "• Render - може бути призупинено або перезапущено • Pre-commit - читання DOM до оновлення • Commit - дії після оновлення DOM",
        "Основні методи": "Монтування: constructor(), render(), componentDidMount() Оновлення: componentDidUpdate(), render() Розмонтування: componentWillUnmount()"
      }
    },
    {
      id: 6,
      title: "React Hooks: useState та useEffect",
      difficulty: "Середній",
      duration: "60 хв",
      completed: false,
      description: "Освойте основні хуки React для управління станом та побічними ефектами.",
      learningPoints: [
        "Що таке хуки та їх переваги",
        "useState для управління станом",
        "useEffect для побічних ефектів",
        "Правила використання хуків"
      ],
      theory: {
        "Хуки": "Хуки - це функції, які додають стан та інші можливості в функціональні компоненти. Назва починається з 'use'. Хуки не можна використовувати за умовою.",
        "Проблеми які вирішують хуки": "1. Спільний код логіки компонентів 2. Складна логіка стану та ефектів 3. Відсутність стану в функціональних компонентах 4. Затримка рендерингу та витрати пам'яті 5. Спільне використання стану між компонентами",
        "useState": "Хук useState дозволяє додавати стан до функціональних компонентів. Додає зміну стану в компонент.",
        "useEffect": "Хук useEffect використовується для виконання побічних ефектів у функціональних компонентах. Являє собою сукупність методів: componentDidMount, componentWillUpdate, componentWillUnmount.",
        "Правила хуків": "1. Використовувати тільки в функціональних компонентах 2. Тільки на верхньому рівні 3. Дотримуватися порядку виклику"
      }
    },
    {
      id: 7,
      title: "Просунуті хуки: useContext, useReducer, useMemo",
      difficulty: "Просунутий",
      duration: "65 хв",
      completed: false,
      description: "Вивчіть просунуті хуки для складного управління станом та оптимізації.",
      learningPoints: [
        "useContext для передачі даних",
        "useReducer для складного стану",
        "useMemo та useCallback для оптимізації",
        "useRef для роботи з DOM"
      ],
      theory: {
        "useContext": "Хук useContext дозволяє отримати значення з контексту, заміняючи необхідність передавати пропси через кілька рівнів компонентів.",
        "useReducer": "Хук useReducer дозволяє керувати станом компонента за допомогою функцій редуктора. Корисний для складного стану.",
        "useMemo та useCallback": "useMemo дозволяє мемоізувати результат обчислення. useCallback мемоізує функції, щоб уникнути непотрібного рендерингу.",
        "useRef": "Хук useRef допомагає зберігати значення між рендерами компонента, але не викликає повторний рендер при зміні цього значення."
      }
    },
    {
      id: 8,
      title: "Context API та глобальне управління станом",
      difficulty: "Просунутий",
      duration: "50 хв",
      completed: false,
      description: "Використання Context API для передачі даних через дерево компонентів.",
      learningPoints: [
        "Створення та використання Context",
        "Provider та Consumer",
        "Передача функцій через контекст",
        "Оптимізація контексту"
      ],
      theory: {
        "Context": "Context у React - це механізм, який дозволяє передавати дані вглиб без необхідності передавати пропси через кілька рівнів компонентів.",
        "Використання": "• Загальний контекст для всього додатку • Передача функцій через контекст • Оновлення контексту від подій",
        "Переваги": "Контекст дозволяє створювати більш гнучкі та масштабовані компоненти та полегшує управління станом у додатку.",
        "Оптимізація": "Розділяйте контексти на логічні частини та використовуйте мемоізацію для запобігання зайвих рендерів."
      }
    },
    {
      id: 9,
      title: "Маршрутизація з React Router",
      difficulty: "Середній",
      duration: "55 хв",
      completed: false,
      description: "Навігація в односторінкових додатках за допомогою React Router.",
      learningPoints: [
        "Налаштування React Router",
        "Основні компоненти: Router, Route, Link",
        "Параметри маршрутів",
        "Програмна навігація"
      ],
      theory: {
        "React Router": "React Router - це бібліотека для реалізації навігації в односторінкових додатках (SPA). Вона дозволяє створювати маршрути, що відображають різні компоненти на основі URL.",
        "Основні елементи": "1. BrowserRouter - обгортка для всього додатка 2. Route - визначає шлях і компонент 3. Switch - рендеринг лише одного компонента 4. Link - посилання без перезавантаження 5. NavLink - посилання з активним стилем",
        "Маршрутизація": "Маршрутизація дозволяє керувати вмістом веб-додатка та визначити, який компонент відображати для конкретного шляху в URL."
      }
    },
    {
      id: 10,
      title: "Оптимізація та просунуті паттерни",
      difficulty: "Просунутий",
      duration: "70 хв",
      completed: false,
      description: "Методи оптимізації React додатків та просунуті паттерни розробки.",
      learningPoints: [
        "React.memo та мемоізація",
        "Межі помилок (Error Boundaries)",
        "Відкладене завантаження (Lazy loading) та Suspense",
        "Власні хуки та паттерни"
      ],
      theory: {
        "Мемоізація": "Мемоізація - це техніка оптимізації, яка забезпечує збереження результатів викликів функцій. React.memo створює мемоізовану версію функціонального компонента.",
        "React.memo": "React.memo дозволяє уникнути зайвих ререндерів в React. Використовують для оптимізації рендерингу та зменшення затрат на виконання компонентів.",
        "Межі помилок": "Компоненти, які ловлять JavaScript помилки в будь-якому місці дерева компонентів та відображають запасний UI.",
        "Відкладене завантаження": "Дозволяє завантажувати компоненти тільки тоді, коли вони потрібні, що покращує початкову швидкість завантаження."
      }
    }
  ]
};