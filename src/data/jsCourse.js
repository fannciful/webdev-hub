export const jsCourseData = {
  title: "Основи JavaScript",
  description: "Повний курс JavaScript від основ до просунутих концепцій. Навчіться програмувати на JavaScript з нуля до професійного рівня.",
  level: "Від початківця до експерта",
  duration: "~20 годин",
  prerequisites: "Базові знання HTML та CSS",
  certificate: "Доступний після завершення всіх модулів",
  topics: [
    {
      id: 1,
      title: "Змінні та типи даних",
      difficulty: "Початківець",
      duration: "45 хв",
      completed: false,
      description: "Основи JavaScript: типи даних, оголошення змінних та робота з різними значеннями.",
      learningPoints: [
        "8 типів даних в JavaScript",
        "Примітивні vs складні типи даних",
        "Відмінності var, let та const",
        "Оператор typeof та перевірка типів"
      ],
      theory: {
        "JavaScript": "JavaScript - це динамічно типізована мова програмування, де змінні можуть змінювати свій тип даних під час виконання програми.",
        "Змінні": "Змінна - це «іменоване сховище» для даних. Ми можемо використовувати змінні для зберігання товарів, відвідувачів та інших даних.",
        "var vs let vs const": `Var - можна ініціалізувати після оголошення, можна змінювати, має функціональну область видимості. Змінна підіймається на верх своєї області видимості, а значить до неї можна звернутися до її оголошення у такому випадку її значенням буде undefined. Зараз майже не використовують цю змінну.
Let - змінну можна ініціалізувати після оголошення, можна змінювати, має блокову область видимості.
Const - змінну обов'язково потрібно ініціалізувати під час оголошення, не можна змінювати, має блокову область видимості.`,
        "Типи даних": `Існує 8 типів даних. 7 примітивних та 1 складний тип даних.
Примітивні типи: number, string, boolean, symbol, bigInt, null, undefined
Складний тип: object, array, function 
Він використовується для колекцій даних та для оголошення більш складних сутностей. Також він передається за посиланням, а прості типи даних за значенням.`,
        "Number": "Number - тип даних, що використовується для представлення числових значень, як цілих, так дійсних.",
        "BigInt": "BigInt - тип, щоб працювати з цілими числами довільної довжини.",
        "String": "String - тип для представлення текстової інформації.",
        "Boolean": "Boolean - існує 2 можливих значення: true і false.",
        "Null": "Null - відсутність значення. Використовується для присвоєння змінної порожнього або невідомого значення.",
        "Undefined": "Undefined - вказує на змінну, яка була оголошена, але не має значення. Використовується для перевірок, чи була змінна призначена.",
        "Symbol": "Symbol - цей тип використовується для створення унікальних ідентифікаторів в об'єктах.",
        "Object": "Object - це самостійна одиниця, що має властивості та методи. У об'єктах зберігаються колекції даних чи складні структури.",
        "Відмінності між примітивами та посиланнями": `Примітиви надаються за значенням, тобто копіюються, коли створюється нова змінна.
Посилання (об'єкти) передаються за посиланням, тобто вказують на один і той самий об'єкт в JavaScript.`,
        "Копіювання об'єкта": `1. Spread operator(…) - дозволяє копіювати властивості з одного об'єкта в інший.
2. Object.assign() - дозволяє копіювати властивості з одного або більше об'єктів до цільового об'єкта
3. JSON.stringify() - використовуємо для перетворення об'єкта в рядок JSON, а потім JSON.parse() - використовуємо для створення об'єкта з цього рядка.`,
        "Оператор typeof": "Оператор typeof - це оператор, який дозволяє визначити тип даних змінної або виразу в JavaScript."
      }
    },
    {
      id: 2,
      title: "Оператори та порівняння",
      difficulty: "Початківець",
      duration: "35 хв",
      completed: false,
      description: "Дізнайтеся про різні типи операторів в JavaScript та особливості порівняння значень.",
      learningPoints: [
        "Арифметичні та присвоювальні оператори",
        "Логічні оператори: І, АБО, НІ",
        "Оператори порівняння",
        "Тернарний оператор та switch"
      ],
      theory: {
        "Унарні оператори": `Унарні оператори - це оператори, які працюють з одним операндом, тобто змінною чи значенням.
Унарний плюс (+) - перетворює операнд в число.
Унарний мінус (-) - змінює знак числа на протилежний.
Унарний оператор заперечення (!) - інвертує значення логічного операнду`,
        "Типи унарних операторів": `1. Передоператор - це унарний оператор, який змінює значення операнду перед тим як виконується дія.
2. Постоператор - це унарний оператор, який зменшує значення операнду після того, як виконано дію.`,
        "Оператори присвоювання": `Оператори присвоювання використовуються для присвоєння значення змінній. Найпростішим оператором присвоювання є =
Інкремент та декремент - це оператори для збільшення або зменшення значення змінної на 1.
Існують дві форми: префіксна (++х) та постфіксна (х++)`,
        "Бінарні та арифметичні оператори": `Бінарні операції - це ті, що приймають 2 операнди та повертають 1 значення.
Арифметичні операції - це підмножина бінарних операцій, що виконують математичні дії, такі як додавання, віднімання, множення, ділення.`,
        "Логічні оператори": `&& (логічне «І» або «AND»)
|| (логічне «АБО» або «OR»)
! (Логічне заперечення)
? (використовується для визначення значення за замовчуванням для змінної, яка може бути null або undefined)`,
        "Тернарний оператор": `Тернарний оператор - приймає три операнди і виконує умову операції на підставі значення умови.
умова ? вираз 1 : вираз 2
Якщо умова істинна - виконується вираз 1, інакше - вираз 2.`,
        "Конструкція switch": "Конструкція switch замінює собою відразу декілька if",
        "Оператори порівняння": `Вони дозволяють визначити відносини між об'єктами та даними і відповідають на питання, чи вірне одне значення відносно іншого.
Оператори < та >
Оператори <= та >=
Оператори in (використовується для перевірки чи містить об'єкт вказану властивість)`,
        "Явне та неявне перетворення": `Явне перетворення типів даних - відбувається за допомогою різних функцій та методів, які дозволяють змінювати тип даних змінних на конкретний тип.
Неявне перетворення типів даних - відбувається автоматично в певних випадках, коли JS намагається виконати операції над різними типами даних.`,
        "Модальні вікна": `Alert - функція показує модальне вікно з повідомленням поки користувач не натисне ОК.
Prompt - функція показує модальне вікно для вводу тексту користувачем.
Confirm - функція показує модальне вікно з питанням та 2 кнопками: ОК та скасувати.`,
        "Шаблонні рядки": "Шаблонні рядки - це потужний інструмент для створення та форматування рядків в JS",
        "Округлення чисел": `Math.floor - округлює вниз 
Math.ceil - округлює вгору
Math.round - округлює до найближчого цілого
Math.trunc - відкидає дрібну частинку`
      }
    },
    {
      id: 3,
      title: "Цикли",
      difficulty: "Початківець",
      duration: "40 хв",
      completed: false,
      description: "Освойте різні типи циклів для багаторазового виконання коду.",
      learningPoints: [
        "Цикл while та do...while",
        "Цикл for та його варіанти",
        "for...in та for...of",
        "break, continue та вкладені цикли"
      ],
      theory: {
        "Цикли": `Цикли - передбачені для багаторазового використовування однієї ділянки коду.
Код виконується доти, доки умова істинна.
Є 3 основні типи циклів: 
1. For
2. While
3. Do…while`,
        "While": `Доки умова є вірною, код із циклу виконується
while (умова) {
   тіло циклу
}`,
        "Do...while": "Якщо хочемо, щоб тіло циклу виконалося хоча б один раз, навіть якщо умова хибна.",
        "For": `Це найпоширеніший вид циклу. Він дозволяє вказати початкову умову, умову виходу та крок ітерації.
For (ініціалізація, умова, ітерація) {
   тіло циклу
}`,
        "For...in": `Для ітерації по властивостях об'єкта
const obj = {
   a: 10,
   b: 15,
   c: 20
}

for (const key in obj) {
   console.log(key) // a b c
}`,
        "For...of": `Для ітерації по об'єктах
const array = [1, 2, 3, 4, 5]

for (const key of array) {
   console.log(key) // 1 2 3 4 5
}`,
        "Break та Continue": `Break - ми можемо перервати цикл та вийти з нього 
Continue - припиняє не весь цикл, а тільки поточну ітерацію`,
        "Вкладені цикли": "Вкладені цикли - це цикли, які знаходяться всередині інших циклів.",
        "Нескінченні цикли": "Нескінченні цикли - це цикли, які ніколи не завершуються при нормальних умовах."
      }
    },
    {
      id: 4,
      title: "Функції",
      difficulty: "Середній",
      duration: "50 хв",
      completed: false,
      description: "Глибоке розуміння функцій, області видимості та різних способів створення функцій.",
      learningPoints: [
        "Function Declaration vs Function Expression",
        "Область видимості функцій",
        "Чисті та анонімні функції",
        "Повернення значень з функцій"
      ],
      theory: {
        "Функції": "Функції - дозволяють організувати код, забезпечуючи його повторне використання та сприяють створенню більш структурованих програм.",
        "Види оголошення функцій": "Є 2 види оголошення функцій: function declaration та function expression.",
        "Область видимості": `Змінні, оголошені всередині функції, видно лише всередині функції.
Проте, функція має доступ до зовнішніх змінних.`,
        "Повернення функції": "Функції можуть повертатися за допомогою ключового слова return.",
        "Ім'я функції": "Ім'я функції зазвичай є дієсловом та починається з маленької букви.",
        "Чисті функції": "Чистою може бути функція, яка повертає однаковий результат, якщо викликається з тим самим набором аргументів.",
        "Анонімні функції": `Це функції, які не мають імені або імені змінної і є одноразовими або невеликими.
Приклади використання анонімних функцій: 
1. Як функція колбек
2. Анонімна функція, передана як аргумент
3. Анонімна функція, яка викликається сама
4. Замикання`,
        "Стрілкові функції": `Стрілкові функції - це спрощена синтаксична форма визначення функцій.
Стрілкові функції не мають свого контексту this, що робить їх зручними у використанні в ООП.`,
        "Функції вищого порядку": "Це функції, які приймають інші функції як аргументи або повертають їх як результат."
      }
    },
    {
      id: 5,
      title: "Замикання та функції вищого порядку",
      difficulty: "Середній",
      duration: "55 хв",
      completed: false,
      description: "Розуміння замикань, колбеків, IIFE та каррінгу функцій.",
      learningPoints: [
        "Замикання та їх практичне застосування",
        "Callback функції",
        "IIFE (негайно викликувані функції)",
        "Каррінг та методи масивів"
      ],
      theory: {
        "Функція-колбек": "Функція-колбек - це функція, яка передається іншій функції як аргумент, яка потім викликається після завершення будь-якої дії.",
        "Функція вищого порядку": "Називається функція, яка бере функцію як аргумент або повертає функцію у вигляді вихідного значення.",
        "IIFE": "IIFE (Immediately Invoked Function Expression) - це JavaScript функція, яка виконується відразу після того, як вона була визначена.",
        "Основні методи масивів": `Основні методи масивів, які використовують функції вищого порядку: 
map() - цей метод створює новий масив, застосовуючи задану функцію до кожного елемента початкового масиву
filter() - цей метод створює новий масив, включаючи тільки ті елементи, для яких задана функція повертає true (тобто сортує)
reduce() - цей метод застосовує задану функцію до всіх елементів масиву та акумулює результати в одне значення
forEach() - цей метод виконує задану функцію для кожного елемента масиву, але не створює новий масив.`,
        "Функція що самовикликається": "IIFE (самовикликаюча функція) - це інструмент в JS, який дозволяє створювати функції та викликати їх безпосередньо після визначення.",
        "Чисті функції детально": `Це функції, які мають певні властивості, спрощуючи розробку і розуміння коду.
Основні характеристики: 
1. Чиста функція завжди повертає однаковий результат для однакових вхідних даних 
2. Чиста функція не змінює стану програми і не виконує операцій
3. Результат виконання не залежить від порядку виклику функцій.`,
        "Каррінг": `Каррінг - це техніка в функціональному програмуванні, яка полягає в трансформації функції з багатьма аргументами в послідовність функцій з одним аргументом кожна
Не як name(a, b, c) а як name(a)(b)(c)`,
        "Замикання": "Замикання - це функція, що має доступ до своєї зовнішньої функції в області видимості, навіть після того, як зовнішня функція припинилася."
      }
    },
    {
      id: 6,
      title: "Стрілкові функції та контекст this",
      difficulty: "Середній",
      duration: "45 хв",
      completed: false,
      description: "Розуміння стрілкових функцій, контексту this та методів зміни контексту.",
      learningPoints: [
        "Стрілкові функції та їх особливості",
        "Контекст this в різних ситуаціях",
        "Методи call, apply, bind",
        "Різниця між стрілковими та звичайними функціями"
      ],
      theory: {
        "Стрілкові функції детально": "Стрілкові функції - це інструмент JS, ідеальний для простих функцій, що використовуються для обробки подій, маніпулювання масивами, фільтрації даних та інших операцій.",
        "Відмінності від звичайної функції": `Відмінності від звичайної функції:
Відсутність this
Неможливість використовувати arguments`,
        "Контекст виклику в JavaScript": `Він визначає, як функції отримують доступ до об'єкту, в якому вони були викликані.
1. Глобальний контекст виклику
2. Контекст виклику функції
3. Зміна виклику контексту змінити можна за допомогою методів: call(), apply(), bind()
4. Контекст виклику при обробці подій`,
        "Методи зміни контексту": `Метод bind() - створює нову функцію, яка при виклику встановлює як контекст виконаного this цього наданого значення 
Метод call() та apply() - викликають функцію із зазначеним контекстом this та додатковими аргументами`,
        "Конструктор об'єкту": `Функції-конструктори є стандартними функціями.
1. Ім'я функції - конструктора має починатися з великої літери 
2. Функція конструктор повинна викликатися за допомогою оператора «new».`
      }
    },
    {
      id: 7,
      title: "Рекурсія та функції-конструктори",
      difficulty: "Середній",
      duration: "50 хв",
      completed: false,
      description: "Розуміння рекурсії та створення об'єктів за допомогою функцій-конструкторів.",
      learningPoints: [
        "Принципи рекурсії",
        "Функції-конструктори",
        "Створення багаторазових об'єктів",
        "Кастомні методи об'єктів"
      ],
      theory: {
        "Рекурсія": `Рекурсія - це термін у програмуванні, що означає виклик функцією себе.
У рекурсивних функціях завдання ділиться на більш прості підзавдання, і функція викликається для кожного з цих підзавдань до завершення всього завдання.`,
        "Завдання для рекурсії": `Завдання, де рекурсія є найкращим вибором: 
Пошук у глибину 
Форматування дерева об'єктів
Графічні інтерфейси`,
        "Функція-конструктор": "Функція-конструктор - це спеціальна функція в JS, призначена для створення нових об'єктів певного типу.",
        "Створення багаторазових об'єктів": "Можливість створення багаторазові об'єкти одного типу.",
        "Інкапсуляція даних": "Можемо використовувати приватні властивості та методи для збереження даних та додаткової логіки в межах об'єкта.",
        "Наслідування та прототипи": "Можуть бути використані для створення прототипів об'єктів, що дозволяє створювати ієрархію об'єктів та спадкувати їхню функціональність.",
        "Варіативність та параметри": "Можемо передавати різну кількість аргументів при створенні об'єктів",
        "Кастомні методи об'єкта": "Методи об'єкта - це функції, які відомі об'єкту та можуть викликатися для виконання певних операцій над об'єктом.",
        "Відмінність методів об'єкта": "Методи об'єкта завжди пов'язані з об'єктом, на якому вони були викликані. Це означає, що метод може отримувати доступ до властивостей об'єкта через ключове слово this."
      }
    },
    {
      id: 8,
      title: "Масиви та об'єкти",
      difficulty: "Середній",
      duration: "60 хв",
      completed: false,
      description: "Глибоке вивчення роботи з масивами, об'єктами та їх методами.",
      learningPoints: [
        "Створення та робота з об'єктами",
        "Методи об'єктів: Object.keys(), Object.values()",
        "Деструктуризація об'єктів та масивів",
        "Основні методи масивів"
      ],
      theory: {
        "Об'єкт": `Об'єкт - це самостійна одиниця, що має властивості і методи.
Властивості об'єкта по-суті є тими самими змінними в JS, за вийнятком, що вони закриті за об'єктом.
Отримати доступ до властивості об'єкта можна так: ObjectName.value`,
        "For..in": "Цикл проходить через властивості об'єкта, що перераховуються. Він пройде по кожному елементу окремо",
        "Метод": "Метод - це функція, асоційована з об'єктом або це властивість об'єкта, що є функцією. Методи визначаються так само як звичайні функції.",
        "Методи об'єктів": `Object.keys(), Object.values(), Object.entries() - дозволяють отримати масив ключів, масив значень та масив пар ключ-значення.
Object.assign() - використовується для копіювання властивостей з одного та декількох об'єктів в цільовий об'єкт.
hasOwnProperty() - використовується для перевірки наявності властивості в об'єкті. Повертає true, якщо властивість існує і false, якщо ні.`,
        "Деструктуризація": "Деструктуризація - це спосіб отримання окремих властивостей об'єкта та присвоєння їх змінним.",
        "Масиви": `Масиви - це впорядкована колекція значень. Значення в масиві називаються елементами, і кожен елемент характеризується числовою позицією в масиві, яка називається індексом.
Масиви в мові JS є не типізованими: елементи масиву можуть мати будь-який тип, причому різні елементи одного і того ж масиву можуть мати різні типи.
Не мають окремого типу, бо відносяться до об'єкта.
Вони створюються за допомогою [] та заповнюються значеннями. Масиви можуть містити числа, рядки, об'єкти та навіть інші масиви.`,
        "Базові операції з масивами": `Створення масиву
Отримання доступу до елементу
Зміна значення
Отримання довжини масиву`,
        "Способи створення масивів": `1. Літеральний спосіб створення масиву без використання конструктора Array
2. З використанням конструктора Array  const numbers = new Array(«red», «yellow», «black»)
3. Спрощений синтаксис створення масиву для створення масиву заданого розміру  const numbers = new Array(5)`,
        "Додавання та видалення елементів": `Методи push, pop, unshift, shift - дозволяють додавати та видаляти елементи, а splice - надає більше контролю над редагуванням масиву.
Додавання елементу в кінець масиву fruits.push(«grape»)
Видалення останнього елементу fruits.pop(«grape»)
Додавання елементу на початок масиву fruits.unshift(«grape»)
Видалення першого елементу fruits.shift(«grape»)`,
        "Основні методи масивів": "Методи, що дозволяють вирішувати різноманітні завдання з масивами: join, concat, slice, spice",
        "Методи перебору масиву": `1. Цикл for  базовий метод перебору масивів. Використовуємо індекси для доступу до елементів масиву
2. Цикл for…of цей цикл спрощує перебір масиву, оскільки ми вказуємо змінну для кожного елемента масиву.
3. Метод forEach метод forEach є методом масиву, який приймає функцію зворотного виклику та застосовує її до кожного елемента масиву.
4. Метод map метод map також приймає функцію зворотного виклику та створює новий масив, в якому кожен елемент є результатом функції.`,
        "Збереження та копіювання масивів": `1. Просте присвоєння при присвоєнні масиву іншій змінній створюється посилання на оригінальний масив, тому зміни в одному вплинуть на інший
2. Метод slice() створює новий масив, який містить підрядок оригінального масиву.
3. Оператор розширення (…) створює новий масив і копіює значення з оригінального масиву`,
        "Копіювання масиву": `1. Метод concat() створює новий масив, об'єднуючи два (або більше) масиви
2. Метод Array.form() створює новий масив з інтегрованого об'єкта, такого як масив або строк
3. Оператор розширення spread operator(…) використовується для створення глибоких копій об'єктів та масивів.`
      }
    },
    {
      id: 9,
      title: "Події та BOM",
      difficulty: "Середній",
      duration: "55 хв",
      completed: false,
      description: "Робота з подіями DOM, спливання подій та Browser Object Model.",
      learningPoints: [
        "Фази подій: захоплення, цільова, спливання",
        "Делегування подій",
        "BOM: window, location, navigator, history",
        "Робота з URL та screen об'єктом"
      ],
      theory: {
        "Спливання подій": `Спливання подій - це аспект подій в DOM, який означає, що події можуть поширюватися вгору по ієрархії елементів DOM після того, як вони були спровоковані. Спливання подій дозволяє реагувати на події на різних рівнях DOM-дерева без необхідності призначення обробників подій для кожного елемента окремо.`,
        "Важливість спливання": `Для чого це важливо? 
1. Доступність для різних рівнів DOM
2. Зменшення дублювання коду 
3. Можливість зупинити спливання`,
        "Фази подій": `Фази подій - це концепція, що описує порядок, в якому події розгортаються та обробляються у браузері. 
Існують 3 основні фази подій: 
1. Фаза захоплення 
2. Фаза цільового об'єкта
3. Фаза спливання`,
        "Фаза захоплення": "Це перша фаза розгортання подій, коли подія спускається вниз від кореня DOM-дерева до цільового елемента. Обробники подій викликаються в порядку від найвищого рівня предка до цільового елемента.",
        "Фаза цільового об'єкта": "Відбувається, коли подія досягає цільового елемента, на якому вона була спровокована.",
        "Фаза спливання": "Це остання фаза розгортання подій, коли подія починає підніматися вгору від цільового елемента до кореня DOM-дерева. Обробники подій викликаються в порядку від цільового елемента до найвищого рівня предка.",
        "Механізм спливання": `Механізм спливання подій полягає в тому, що коли подія спрацьовує на конкретному елементі DOM, вона спочатку обробляється на цьому елементі, а потім починає підніматися вгору по ієрархії DOM. 
Простими словами, коли подія відбувається на елементі, спочатку запускаються обробники на ньому, потім на його батькові, потім на інших предках і так до самого верху.
Майже всі події спливають!`,
        "Делегування подій": `Делегування подій - це підхід до обробки подій в JS, при якому обробники подій призначаються батьківському елементу для обробки подій, спровокованих дочірніми елементами.`,
        "Коли використовувати делегування": `В яких випадках варто використовувати делегування? 
1. Багато схожих елементів 
2. Динамічно створені елементи`,
        "Переваги делегування": `Оптимізація роботи з багатьма елементами - замість того, щоб призначати обробник кожному елементу окремо, ви можете використовувати один обробник на батьківському елементі.
Можливість відслідковувати динамічно створені елементи - можна призначити обробник подій батьківському елементу під час завантаження сторінки, і цей обробник буде автоматично відслідковувати всі нові дочірні елементи, які з'являються на сторінці пізніше.`,
        "BOM": `BOM (Browser Object Model) - це частина JS API, яка надає можливість взаємодії з браузером, оточенням, в якому виконується JS код. BOM дозволяє робити різні речі, пов'язані з браузером, такі як керування вікнами і фреймами, зміну URL, роботу з попередженнями і багато іншого. Він є частиною об'єкта window, який представляє веб-сторінку в браузері.`,
        "BOM vs DOM": "DOM забезпечує доступ до вмісту сторінки (елементи, тексти, атрибути), а BOM надає доступ до браузерної функціональності. BOM дозволяє контролювати вікна браузера, отримувати доступ до історії переходів і багато іншого.",
        "Об'єкт window": "Об'єкт window - це головний об'єкт BOM, який представляє веб-сторінку. Він доступний безпосередньо і має глобальну видимість, тобто можна звертатись з будь-якого місця коду.",
        "Властивості window": `Властивість window.location - дозволяє отримати поточну URL сторінки або змінити URL
Метод window.open() - цей метод відкриває нове вікно браузера або нову вкладку з вказаним URL
Властивість window.innerWidth та window.innerHeight - ці властивості повертають розмір вікна браузера у пікселях`,
        "URL": "URL (Uniform Resource Locator) - це рядок, який вказує адресу ресурсу в Інтернеті. URL складається з кількох частин, включаючи протокол, доменне ім'я, шлях до ресурсу та за необхідності параметри запиту.",
        "Об'єкт Location": `Об'єкт Location надає доступ до різних властивостей та методів для роботи з URL поточної сторінки. Він доступний через властивість window.location.
Основні можливості: отримання поточного URL, отримання компонентів URL, зміна URL, перевірка URL`,
        "Об'єкт navigator": `Об'єкт navigator є частиною BOM і містить інформацію про браузер користувача, включаючи характеристики такі як назва браузера, версія, ОС та інше.
navigator.userAgent - містить рядок, який містить інформацію про браузер та ОС користувача
navigator.appName - повертає ім'я браузера 
navigator.appVersion - містить інформацію про версію браузера 
navigator.platform - повертає операційну систему користувача 
navigator.language - містить інформацію про мову браузера користувача
navigator.onLine - вказує, чи встановлено з'єднання з інтернетом`,
        "Об'єкт history": `Об'єкт history - дозволяє взаємодіяти з історією переходів користувача в браузері. Можна також використовувати об'єкт для навігації назад та вперед в історії браузера, а також для отримання інформації про кількість записів в історії та поточний стан.`,
        "Методи history": `Властивість length об'єкта history містить кількість записів в історії браузера.
Об'єкт history надає методи back() та forward(), які дозволяють вам навігувати назад та вперед по історії браузера
Метод go() для переходу на певну сторінку в історії, вказавши кількість кроків, на які треба перейти назад або вперед.`,
        "Об'єкт screen": `Об'єкт screen надає інформацію про екран користувача, таку як розмір, роздільна здатність та інші характеристики екрана.
Для отримання розміру екрана використовуємо властивості width та height
Властивості availWidth та availHeight містять роздільну здатність екрана без урахування панелей інструментів браузера чи інших елементів.
colorDepth - вказує кількість бітів на піксель для відтворення кольорів на екрані 
pixelDepth - аналогічно до colorDepth, вказує кількість бітів на піксель`
      }
    },
    {
      id: 10,
      title: "Форми та регулярні вирази",
      difficulty: "Середній",
      duration: "50 хв",
      completed: false,
      description: "Робота з HTML формами, валідація даних та використання регулярних виразів.",
      learningPoints: [
        "Атрибути форм: action, method, name",
        "Валідація форм: required, pattern, min/max",
        "Об'єкт FormData та його методи",
        "Регулярні вирази та їх застосування"
      ],
      theory: {
        "Веб-форми": `Веб-форми - це незамінний інструмент для збору інформації в інтернеті. Вони дозволяють користувачам вводити дані та взаємодіяти з веб-сайтами.
Основні функції веб-форм включають в себе: 
1. Збір інформації про користувача
2. Взаємодія з користувачем 
3. Збір інформації для аналітики 
4. Здійснення оплати та пожертв
5. Авторизація і автентифікація`,
        "Атрибути action і method": `У HTML-формах існують різні атрибути, які визначають, як саме дані форми будуть оброблятися та надсилатися на сервер. 
Два з найважливіших атрибутів - action і method.
Action - куди відправити дані Тобто, атрибут action визначає URL-адресу, на яку будуть відправлені дані після натискання на кнопку «відправити». 
Method - як відправити дані. Атрибут method вказує метод, який буде використовуватися для відправки даних на сервер. Два основні методи - GET і POST.
GET - використовується для отримання даних з сервера. Дані передаються у URL-запитів.
POST - використовується для надсилання даних на сервер у вигляді тіла запиту.`,
        "Атрибут name": `Атрибут name вказує ім'я поля форми, яке буде використано як ключ для відправлення даних на сервер. Всі дані, введені користувачем в це поле, будуть відправлені під цим іменем у вигляді параметру.
Роль атрибуту name важлива, оскільки вона дозволяє ідентифікувати дані на сервері та прив'язувати їх до конкретних полів форми. Це дозволяє легко обробляти і аналізувати введені користувачем дані.`,
        "Атрибути валідації": `Атрибути та приклади їх використання: 
1. Required вказує, що поле обов'язкове для заповнення
2. Pattern визначає шаблон, якому повинні відповідати введені дані 
3. Min та max встановлення мінімального та максимального допустимого значення для числових полів 
4. minLength та maxLength встановлення мінімальної та максимальної кількості символів для текстових полів 
5. Pattern з виразами можна використовувати регулярні вирази для визначення прийнятних значень`,
        "Події елементів форми": `JS дозволяє створювати інтерактивні форми, які реагують на події, такі як натискання кнопки, введення тексту або відправка даних. Один з найпоширеніших способів використання подій на елементах форми - це валідація даних, які користувач вводить.
Click - спрацьовує при натисканні на елемент 
Submit - спрацьовує при відправці форми 
Input - спрацьовує при введені даних в текстове поле або інший елемент 
Change - спрацьовує при зміні значення елемента 
Focus - спрацьовує при фокусуванні на елементі`,
        "Робота з даними форми": `Використання властивостей value, checked і selected 
1. Зчитування текстових полів: для отримання тексту, який користувач ввів у текстове поле, використовується властивість value 
2. Зчитування прапорцевих (чекбоксів) полів: для чекбоксів та радіокнопок, властивість checked вказує, чи вони вибрані
3. Зчитування значення вибраного варіанту (список): для вибору зі списку використовується властивість selected.`,
        "Обробка подій форми": `1. Подія submit: спрацьовує при надсиланні форми
2. Подія reset: спрацьовує, коли користувач натискає кнопку скидання форми.
3. Подія change: спрацьовує при зміні значення поля форми.`,
        "Об'єкт FormData": `Об'єкт FormData - це об'єкт JS, який дозволяє зручно збирати дані з форми та відправляти їх на сервер. Він автоматично перетворює дані в формат, який може легко обробляти сервер.
Важливі аспекти використання FormData: 
1. Автоматичне створення пар «ключ-значення»
2. Додавання додаткових даних 
3. Асинхронна відправка на сервер 
4. Підтримка різних типів даних`,
        "Методи FormData": `При роботі з об'єктом FormData можна використовувати різні методи для додавання, видалення та редагування даних у формі. 
1. Append (name, value): метод дозволяє додавати пару «ключ-значення» до об'єкта FormData. Приймає 2 аргументи: ім'я ключа та значення 
2. delete(name): видалення ключа та відповідного значення з об'єкта FormData.
3. get(name): отримання значення, яке відповідає ключу name в об'єкті FormData.
4. getAll(name): отримання масиву значень, якщо ключ має декілька значень 
5. has(name): метод has перевіряє, чи існує ключ з ім'ям name в об'єкті FormData
6. set(name, value): для зміни значення ключа
7. keys(), values(), entries(): ці методи повертають ітератори для ключів, значень і пар «ключ-значення» відповідно.`,
        "AJAX": `Технологія AJAX(Asynchronous JavaScript and XML) - дозволяє взаємодіяти з сервером асинхронно та без блокування веб-сторінки. 
AJAX базується на використанні об'єкта XMLHttpRequest (XHR) або сучасного API fetch. Вони дозволяють виконувати HTTP-запити до сервера, такі як GET та POST, і обробляти відповідь асинхронно.`,
        "Регулярні вирази": `Регулярні вирази - це шаблони, які використовуються для пошуку, визначення і вилучення текстових даних, які відповідають певним правилам. Вони дозволяють виразити складні умови для пошуку текстових відповідностей.
В JS можна створити регулярний вираз, використовуючи об'єкт RegExp або літеральний запис. 
Після створення регулярного виразу, можна використовувати його для пошуку в тексті за допомогою методу .test().`,
        "Методи рядків з регулярними виразами": `Метод match - дозволяє знаходити всі відповідності регулярному виразу в рядку. Він повертає масив, що містить всі відповідності 
Метод test - перевіряє, чи відповідає рядок регулярному виразу. Він повертає true, якщо є відповідність, і false, якщо немає
Метод search - шукає позицію першої відповідності регулярному виразу в рядку. Він повертає індекс першої відповідності або -1, якщо відповідності не знайдено.
Метод replace - дозволяє змінювати всі відповідності регулярного виразу у рядку на новий текст.`,
        "Опції регулярних виразів": `При створенні регулярного виразу можна додавати опції, що модифікують його поведінку. Наприклад: 
i - регістронезалежний пошук
g - пошук всіх відповідностей у тексті 
m - пошук в кожному рядку окремо`,
        "Приклади застосування": "Приклади застосування регулярних виразів: пошук email-адреси, вилучення номерів телефонів, валідація email-адреси, валідація URL-адреси"
      }
    },
    {
      id: 11,
      title: "Best Practices та чистий код",
      difficulty: "Середній",
      duration: "45 хв",
      completed: false,
      description: "Принципи написання якісного, читабельного та підтримуваного JavaScript коду.",
      learningPoints: [
        "Правила іменування змінних та функцій",
        "Коментування коду",
        "Оформлення та стиль коду",
        "Оптимізація продуктивності"
      ],
      theory: {
        "Загальні принципи": `1. Читабельність та зрозумілість коду 
2. Підтримуваність та розширюваність проекту 
3. Відсутність зайвих помилок та багів`,
        "Неймінг": `Іменування змінних та функцій впливає на зрозумілість коду. Правильний неймінг покращує розуміння функцій та полегшує уникнення помилок.
1. Дотримання конвенцій іменування 
CamelCase - імена змінних та функцій пишуться з малої літери, окрім першої, і кожне нове слово починається з великої літери (calculateTotalAmount)
snake_case - імена розділяються підкресленням (calculate_total_amount)
PascalCase - кожне слово починається з великої літери (Person)`,
        "Зрозумілі назви": `1. Зрозумілість - назви змінних повинні бути зрозумілими та легко читатися
2. Описовість - імена мають описувати що саме робить функція`,
        "Уникнення абревіатур": "Уникайте використання абревіатур та скорочень, які можуть бути незрозумілими для інших розробників.",
        "Коментування": `Від якості коментарів залежить зрозумілість та підтримуваність коду 
Коментарі для пояснення складних частин коду - основні види коментування - це додати пояснення до складних або нетривіальних частин коду. 
Коментарі для документування API та публічних методів - документація API робить ваш код більш зрозумілим для інших розробників, які його використовують
Уникнення зайвих коментарів - важливо не перевантажувати код зайвими коментарями. Якщо код сам по собі зрозумілий, зайві коментарі можуть створити більше плутанини.`,
        "Оформлення коду": `Дотримання єдиного стилю - всі розробники в команді повинні користуватися однаковими правилами відступів та форматування, щоб код був послідовним та зрозумілим для всіх
Використання автоматичних інструментів - для JS існують різні стандарти форматування, такі як ESLint, Airbnb JS Style Guide, Google JS Style Guide
Prettier - це інструмент, який автоматично форматує код згідно з налаштованими правилами`,
        "Ефективність та оптимізація": `Приклади неоптимальних структур даних:
Зайве витрачання пам'яті
Базові умови вибору структур 
Оптимізації коду для покращення продуктивності`,
        "Гарячі точки": "Один з перших кроків при оптимізації коду - це ідентифікація «гарячих точок» або місць, де програма витрачає найбільше часу. Для цього можна використовувати DevTools або зовнішні профілювальні програми."
      }
    },
    {
      id: 12,
      title: "WebStorage та JSON",
      difficulty: "Середній",
      duration: "40 хв",
      completed: false,
      description: "Робота з локальним сховищем браузера та форматом JSON.",
      learningPoints: [
        "LocalStorage vs SessionStorage",
        "JSON: серіалізація та десеріалізація",
        "Cookies та їх обмеження",
        "Збереження складних об'єктів"
      ],
      theory: {
        "JSON": `JSON (JavaScript Object Notation) - це легкий та легко читаний формат обміну даними. Він широко використовується для передачі даних між веб-серверами та клієнтськими додатками.
Представляє дані у вигляді тексту, що дозволяє легко обмінювати інформацію між різними мовами програмування.`,
        "Використання JSON": `Парсинг JSON: у JS існує функція JSON.parse(), яка дозволяє перетворювати JSON-рядок у об'єкт JS.
Серіалізація в JSON: для перетворення об'єкту JS у JSON-рядок використовується метод JSON.stringify()`,
        "Валідація JSON": "Щоб переконатися чи JSON валідний, використовують функцію JSON.parse() і обробку винятків. Якщо JSON неправильний, це викличе виняток, і його можна обробити.",
        "Застосування JSON": `1. Збереження конфігурацій: JSON використовується для збереження конфігураційних налаштувань додатків
2. Обмін даними з сервером: JSON є популярним форматом для обміну даними між клієнтськими додатками та серверами, наприклад, при використанні API
3. Локальне сховище: JSON дозволяє зберігати дані локально на клієнтському боці, використовуючи LocalStorage або SessionStorage`,
        "LocalStorage": `LocalStorage - це один із механізмів WebStorage в JS, який дозволяє зберігати дані на боці клієнта в браузері.
Цей механізм дозволяє зберігати дані на довший термін, навіть після закриття браузера або перезавантаження сторінки.
LocalStorage має кілька важливих особливостей та можливостей: 
1. Постійність даних 
2. Обмеження обсягу (5-10МБ в залежності від браузера)
3. Легкий доступ до даних 
4. Безпека і обмеження`,
        "SessionStorage": "SessionStorage - це механізм для збереження даних на боці клієнта в рамках однієї сесії браузера. Дані зберігаються лише на час тривалості сесії користувача.",
        "LocalStorage vs SessionStorage": "Основна відмінність в тому, що LocalStorage зберігає дані назавжди, а SessionStorage - лише на тривалість однієї сесії браузера.",
        "Cookies": `Cookies - це невеликі фрагменти даних, які веб-сервери відправляють на браузер користувача, а браузер зберігає їх і повертає знову при кожному запиті до сервера.
В JS використовується document.cookie для роботи з кулі.`,
        "Призначення Cookies": "Основне призначення - це збереження інформації між запитами користувача на веб-сайт. Дозволяють серверам зберігати стан та інші дані для кожного користувача окремо. Це корисно для реалізації таких функцій, як автентифікація, збереження налаштувань, облікові записи користувачів та багато інших.",
        "Переваги та недоліки Cookies": `Основна перевага - стійкість до перезавантаження сторінки або закриття браузера. Можуть мати встановлений термін дії. Це дозволяє зберігати стан автентифікації, рекламні дані та іншу інформацію.
Недоліки: обмеження за розміром (до 4КБ).`
      }
    },
    {
      id: 13,
      title: "ООП в JavaScript",
      difficulty: "Просунутий",
      duration: "65 хв",
      completed: false,
      description: "Об'єктно-орієнтоване програмування: принципи, прототипи, класи та наслідування.",
      learningPoints: [
        "Принципи ООП: інкапсуляція, наслідування, поліморфізм",
        "Прототипи та прототипне наслідування",
        "ES6 класи та їх особливості",
        "Геттери, сетери та статичні методи"
      ],
      theory: {
        "ООП в JavaScript": `Об'єктно-орієнтований JavaScript (ООП) - це підхід до програмування, який дозволяє створювати структуровані та ефективні програми за допомогою об'єктів та класів.
ООП - це спосіб написання коду, що дозволяє створювати об'єкти з допомогою одного об'єкта.
Загальний об'єкт називається планом, проєктом або схемою (blueprint), а створювані з його допомогою об'єкти - екземплярами (instances)`,
        "Екземпляри": "Кожен екземпляр має властивості, що успадковуються від батька, і власні властивості.",
        "Інкапсуляція": `Інкапсуляція - це механізм, що дозволяє обмежити доступ до даних та методів об'єкта та приховувати їх від зовнішнього світу. 
У JS до ES6 інкапсуляція була обмеженою через відсутність модифікаторів доступу, таких як private, protected і public.`,
        "Спадкування": "Спадкування - це потужний механізм, який дозволяє створювати нові класи на основі існуючих класів. При спадкуванні новий клас успадковує властивості та методи від батьківського класу, що полегшує повторне використання коду та розширення функціональності.",
        "Поліморфізм": `Поліморфізм - це принцип, що дозволяє об'єктам різних класів відповідати на однакові запити чи виклики методів за допомогою одного і того ж інтерфейсу.
Поліморфізм може бути досягнутий за допомогою функцій-конструкторів.`,
        "Абстракція": "Абстракція - це процес виділення суттєвих характеристик об'єкта та приховування зайвих деталей. Абстракція дозволяє спростити взаємодію з об'єктами, забезпечуючи інтерфейс для їх використання та приховуючи реалізацію деталей.",
        "Геттери та сетери": "Геттери та селери дозволяють контролювати доступ до властивостей об'єктів.",
        "Геттери": `Геттери - це функції, які дозволяють отримувати значення властивостей об'єктів. Вони підходять для забезпечення безпечного та контрольованого доступу до даних. 
Створення: get + ім'я властивості`,
        "Сетери": `Сетери - це функції, які дозволяють змінювати значення властивостей об'єктів. Вони корисні для контролю за даними та валідації введених значень.
Створення: set + ім'я властивості`,
        "Захист властивостей": "Геттери та сетери можуть використовуватися для захисту властивостей об'єктів від некоректного доступу та невірних значень.",
        "Прототипи": "В JS кожен об'єкт має посилання на інший об'єкт, відомий як «прототип». Прототип визначає базовий набір властивостей та методів, які спільні для всіх об'єктів, створених на основі цього прототипу.",
        "Властивості та методи прототипів": "Властивості та методи прототипу можуть бути використані всіма об'єктами, які успадковують від даного прототипу.",
        "Створення власних прототипів": "Можна створювати власні прототипи для об'єктів. Це корисно, коли хочемо створити багато об'єктів зі спільними властивостями та методами.",
        "Ланцюжки прототипів": `JS дозволяє створювати ланцюжки прототипів, де один об'єкт може мати посилання на інший об'єкт, який, в свою чергу, може мати посилання на інший, і так далі.
Це дозволяє спадкувати властивості та методи від більшого числа прототипів.`
      }
    },
    {
      id: 14,
      title: "Класи",
      difficulty: "Просунутий",
      duration: "55 хв",
      completed: false,
      description: "ES6 класи, конструктори, наслідування та статичні методи.",
      learningPoints: [
        "Створення класів та конструкторів",
        "Наслідування з extends та super",
        "Статичні методи та властивості",
        "Приватні поля та методи"
      ],
      theory: {
        "Переваги класів": `Переваги використання класів у програмуванні:
Організація коду 
Полегшення створення об'єктів 
Спадкування та розширення 
Зрозумілість 
Модульність`,
        "Створення конструктора класу": `Конструктор - це метод з ім'ям constructor, який викликається автоматично при створенні нового екземпляру класу. 
Основна його роль - ініціалізація об'єкта, тобто задання його початкового стану та властивостей.`,
        "Створення об'єктів": "При створенні об'єкта за допомогою класу, конструктор буде автоматично викликаний для ініціалізації властивостей об'єкта",
        "Ініціалізація об'єктів": "Один з ключових аспектів конструктора - це можливість ініціалізувати об'єкт певним початковим станом.",
        "Призначення конструктора": "Конструктор класу використовується для надання об'єктам початкового стану та ініціалізації їхніх властивостей.",
        "Спадкування": "Спадкування в програмуванні - це механізм, що дозволяє класу (підкласу) успадковувати властивості та методи іншого класу (батьківського класу). У JS цей механізм реалізується за допомогою ключового слова extends.",
        "Ключове слово super": "У конструкторі підкласу використовуємо ключове слово super для виклику конструктора батьківського класу. Це необхідно для правильної ініціалізація властивостей, успадкованих від батьківського класу.",
        "Модифікатор public": "Модифікатор public є стандартним для всіх властивостей та методів у класі. Це означає, що вони доступні для використання ззовні класу та можуть бути викликані чи змінені з інших частин програми",
        "Модифікатор private": "Модифікатор private дозволяє обмежити доступ до властивостей та методів тільки всередині самого класу.",
        "Статичні методи": "Дозволяють створювати функціональність, яка відноситься до класу в цілому, а не до конкретних екземплярів. Це корисно для реалізації загальної логіки, яка не пов'язана з конкретним об'єктом.",
        "Переваги статичних членів": `Переваги використання статичних членів класу:
Загальні функції 
Легка доступність 
Збереження загальних даних`,
        "Створення статичних методів": "Для створення використовуємо ключове слово static. Це робить метод чи властивість доступними не для екземплярів класу, а для самого класу.",
        "Використання статичних членів": "Статичні методи та властивості дозволяють реалізувати загальні функції, що не пов'язані з конкретним екземпляром класу."
      }
    },
    {
      id: 15,
      title: "Асинхронне програмування",
      difficulty: "Просунутий",
      duration: "70 хв",
      completed: false,
      description: "Опануйте асинхронний JavaScript: Promise, async/await, Event Loop та обробку помилок.",
      learningPoints: [
        "Синхронний vs асинхронний код",
        "Event Loop та його компоненти",
        "Promise та його методи",
        "async/await синтаксис"
      ],
      theory: {
        "Синхронний та асинхронний код": `Синхронний код виконується послідовно, операція за операцією. Кожен блокуючий виклик чекає завершення попереднього, що може призводити до зупинки виконання.
Асинхронний код виконується паралельно, без очікування завершення попередніх операцій.`,
        "Важливість асинхронності": `Важливість асинхронності для JS:
Завантаження ресурсів
Робота з сервером
Запуск функцій в фоновому режимі 
Очікування подій 
Паралельність операцій`,
        "setInterval, setTimeout": `setInterval дозволяє виконувати функцію через певний інтервал часу. Це корисно для періодичних завдань, таких як оновлення часових годинників або відправлення запитів на сервер 
setTimeout дозволяє досягти затримку виклику функції.
clearTimeout для управління асинхронним кодом та його відміни`,
        "Деталі роботи таймерів": `setInterval Вбудований метод JS, який використовується для періодичного виклику функції через зазначений проміжок часу.
Синтаксис: setInterval(callback, delay)
Callback - функція, яку потрібно викликати 
Delay - інтервал в мілісекундах

setTimeout - використовується для виклику функції, але тільки один раз після затримки 
Синтаксис: setTimeout(callback, delay)
Callback - функція для виклику
Delay - затримка в мілісекундах 
Виклик setTimeout буде повертати ідентифікатор 

clearTimeout - для відміни запланованого виклику функції, який був створений за допомогою setTimeout. Використовуємо, коли хочемо скасувати подальше виконання коду, який був запланований для виклику після певного періоду затримки.
Основний принцип роботи: передача ідентифікатора таймера, який ви хочете скасувати.`,
        "Event Loop": `Event Loop (петля подій) - це механізм у багатьох мов програмування, включаючи JS, який керує потоком виконання подій або запитів в програмі.
Основна ідея - програмам необхідно постійно очікувати на події або запити, які можуть виникнути асинхронно. Замість блокування виконання програми, Event Loop дозволяє програмі продовжувати виконувати інші завдання, поки очікується на результат або подію.`,
        "Ідея циклу подій": "Існує нескінченний цикл подій, в якому JS рушій чекає своє завдання, виконує його і чекає на нове.",
        "Основні частини Event Loop": `Call Stack (стек). Являє собою потік виконання коду JS. Event Loop виконує одне просте завдання - здійснює контроль стеку викликів та черги зворотних викликів. Якщо стек порожній, цикл подій візьме першу подію з черги і відправить її в стек викликів, який запустить. При виклику нового способу зверху стека виділяється окремий блок пам'яті. Стек викликів відповідає за відстеження всіх операцій у черзі, які мають бути здійснені. При завершенні черги вона витягується зі стека.

Heap (купа). Це область пам'яті, де розміщуються об'єкти. Куча не має строгого порядку і дозволяє динамічно виділяти і звільняти пам'ять для об'єктів.

Queue (черга). Черга подій відповідає за надсилання нових функцій на трек обробки. Він слідує структурі даних черги, щоб підтримувати правильну послідовність, в якій всі операції повинні надійти на виконання. Якщо простіше, то це і є список завдань, які повинні вирушити на обробку і чекають свій час.

Web API. Не є частиною JS, вони створені на основі JS. Щоразу, коли викликається асинхронна функція, вона відправляється до API браузера. На основі команди, отриманої зі стеку викликів, API запускає власну однопотокову операцію.`,
        "Черга подій": `Під час виклику setTimeout(), браузер або Node.js запускають таймер. Після закінчення таймера, як тайм-аут, функція зворотного виклику поміститься в чергу подій.
Черга подій також є місцем, де ініційовані користувачем події розміщуються в чергу до того, як коду зможе на них відреагувати.
Event Loop надає пріоритет стеку викликів. Спочатку він обробляє все, що знаходить у стеку викликів, а коли там нічого не лишається, переходить до обробки черги подій.`,
        "Callback Hell": `Callback Hell виник через особливості асинхронного програмування в JS. За невеликий час використання цього підходу, код може стати густим, непереглядним та важким для управління.
Суть проблеми: вкладеність колбеків та важкість читання коду 
Головна проблема Callback Hell - це велика кількість вкладених колбеків. Коли є багато асинхронних операцій, які повинні відбуватися послідовно, код виглядає подібно до «п'ятиконтурного пекла».`,
        "Promise": `Promise - це об'єкт, який представляє результат або помилку асинхронної операції та дозволяє вас працювати з результатом асинхронного запиту в подальший час.`,
        "Структура Promise": `Створення промісу:
const promise = new Promise((resolve, reject) => {
  // Асинхронний код, який вирішує (resolve) або відхиляє (reject) проміс
});

Методи Promise:
then() - викликається, коли проміс вирішується успішно 
catch() - викликається, коли проміс відхиляється
finally() - викликається незалежно від того, чи вирішується, чи відхиляється проміс`,
        "Переваги Promise": `Переваги в порівнянні з Callback Hell:
Читабельність коду 
Управління помилками 
Зручність роботи з асинхронним кодом`
      }
    },
    {
      id: 16,
      title: "Ajax та async/await",
      difficulty: "Просунутий",
      duration: "60 хв",
      completed: false,
      description: "Робота з сервером: Ajax, fetch API, async/await та HTTP методи.",
      learningPoints: [
        "Ajax та XMLHttpRequest",
        "Fetch API та його переваги",
        "HTTP методи: GET, POST, PUT, DELETE",
        "async/await синтаксис"
      ],
      theory: {
        "Ajax": `Ajax (Asynchronous JavaScript and XML)- це метод взаємодії з сервером без перевантаження сторінки, що дозволяє асинхронно відправляти та отримувати дані.
Ajax - це техніка асинхронного обміну даними між клієнтом та сервером без необхідності перезавантаження сторінки. Ця технологія дозволяє виконувати запити до сервера, отримувати та відправляти дані, а потім динамічно оновлювати частини сторінки.`,
        "Роль Ajax": "Ajax грає ключову роль у створенні динамічних та інтерактивних веб-застосунків. За допомогою Ajax, ви можете асинхронно завантажувати дані, взаємодіяти з сервером, оновлювати інформацію на сторінці та створювати більш плавні та швидкі веб-додатки.",
        "XMLHttpRequest": `Об'єкт XMLHttpRequest дозволяє асинхронно взаємодіяти з сервером. Основні етапи використання XMLHttpRequest: створення об'єкта, визначення типу запиту (GET, POST), вказання адреси сервера та обробку відповіді.`,
        "Синтаксис XMLHttpRequest": `Створення об'єкта XMLHttpRequest:
Для створення об'єкта XMLHttpRequest використовується конструктор: 
Const xhr = new XMLHttpRequest();

Відкриття запиту 
Метод open() використовується для налаштування параметрів запиту, таких як тип (GET, POST) та адреса сервера 

Визначення функції зворотного виклику 
Метод onreadystatechange встановлює функцію зворотного виклику, яка буде викликана при зміні стану запиту 

Відправлення запиту 
Метод send() використовується для відправлення запиту на сервер 

Обробка відповіді 
Функція зворотного виклику перевіряє стан та статус запиту. Якщо стан - 4 (завершено), а статус - 200 (ОК), то виводиться вміст відповіді.`,
        "Fetch API": `fetch API - це інтерфейс, який надає вам можливість контролювати різні параметри запиту, такі як метод, заголовки, тіло, режим, перенаправлення тощо. Він надає зручний і простий спосіб взаємодії з сервером та отримання або відправлення даних. Основні особливості fetch включаються проміс-підтримку та вбудовані методи для обробки HTTP-відповідей.`,
        "HTTP методи": `GET, POST, PUT, DELETE - це 4 основні методи HTTP-запитів, які використовуються для взаємодії між клієнтом і сервером у веб-розробці.
Ці методи HTTP є частиною стандарту REST і використовуються для забезпечення повноцінної реалізації CRUD-операцій (створення, читання, оновлення, видалення) у веб-розробці.`,
        "GET-запит": `Використовується для отримання даних з сервера 
Підходить для запитів, які не змінюють стан сервера і призначені лише для отримання інформації`,
        "POST-запит": `Використовується для надсилання даних на сервер для обробки або збереження 
Параметри передаються у тілі запиту
Використовується там, де потрібно змінити стан сервера`,
        "PUT-запит": `Використовується для оновлення чи створення ресурсу на сервері за вказаним URL
Якщо ресурс існує, він оновлюється; якщо відсутність - створюється новий 
Запит має містити повний опис ресурсу`,
        "DELETE-запит": `Використовується для видалення ресурсу на сервері за вказаним URL
Запит не має тіла, оскільки весь інформаційний вміст передається у URL`,
        "Async...await": "Async...await є синтаксичним цукром над Promise, що робить код асинхронного JS більш зрозумілим та зручним для написання. Ключове слово async вказує, що функція повертає Promise, а await використовується для очікування виконання Promise та отримання його результату.",
        "Async функції": "Ключове слово async використовується для визначення функції, яка повертає обіцянку (promise). Функція, яка має async перед своєю декларацією, автоматично повертає Promise",
        "Await оператор": `Оператор await працює тільки в межах async функцій. Він призупиняє виконання функції до тих пір, поки передана обіцянка не буде виконана або відхилена, та повертає його результат.
await призупиняє виконання функції до тих пір, поки проміс не виконується, а потім відновлює її з результатом проміса.`,
        "Використання async/await": `Використання: 
Використання в контексті функцій
Використання в контексті обіцянок`
      }
    },
    {
      id: 17,
      title: "Бібліотеки та npm",
      difficulty: "Просунутий",
      duration: "50 хв",
      completed: false,
      description: "Робота з пакетним менеджером npm та популярними JavaScript бібліотеками.",
      learningPoints: [
        "npm та package.json",
        "Встановлення та управління пакетами",
        "jQuery: основи та можливості",
        "Використання зовнішніх бібліотек"
      ],
      theory: {
        "npm": `Npm (node package manager) - це менеджер пакетів Node.js. 
Спочатку npm створювався як система управління пакетами для Node.js, але в наші дні він використовується і для розробки фронтенд-пакетів на JavaScript.`,
        "package.json": `Файл package.json - це конфігураційний файл проекту, де містяться основні відомості, такі як назва проекту, версія, автор, а також перелік залежностей. Створення його можливе за допомогою команди: npm init`,
        "package-lock.json": "Файл package-lock.json використовується для фіксації версій всіх встановлених пакетів. Це гарантує, що всі розробники, які використовують проект, отримають однакові версії пакетів, що сприяє стабільності та однаковості серед учасників команди.",
        "Встановлення залежностей": "Якщо проект має файл package.json, то встановити всі залежності цього проекту можна такою командою: npm install",
        "Встановлення окремого пакету": `За допомогою команди npm install <package-name>, розробники можуть легко встановлювати пакети, необхідні для їхніх проектів.
Npm install lodash`,
        "Запуск скриптів": `Файл  package.json підтримує можливість опису команд (скриптів), які можна запускати за допомогою такої конструкції
Npm run <task-name>`,
        "Встановлення пакетів": `При встановленні пакетів з використанням npm доступні два варіанти встановлення: локальна та глобальна.
Глобальне встановлення пакетів виконується за допомогою прапора -g
Npm install -g lodash`,
        "node_modules": "Папка node_modules містить велику кількість файлів пакетів, які розраховані на внутрішнє використання. з метою зменшення обсягу репозиторію та прискорення клонування, рекомендується додати цю папку до файлу .gitignore, щоб вона не включалася до репозиторію та не зберігалася в системах контролю версій.",
        "jQuery": "jQuery - це одна з найпопулярніших та використовуваних бібліотек JavaScript, яка спрощує взаємодію з DOM, обробку подій та роботу з AJAX-запитами.",
        "Проблеми що вирішує jQuery": `Різні реалізації DOM в різних браузерах 
Вибір елементів та події 
Анімація та зміна стилів 
AJAX-запити 
Кросбраузерна обробка подій`,
        "Можливості jQuery": `Одна з ключових можливостей: легкий та зручний вибір елементів за допомогою CSS-подібного синтаксису.
jQuery надає розгалужену функціональність для обробки подій, зміни стилів, анімації та взаємодії з сервером через AJAX.
jQuery використовує лаконічний та зрозумілий синтаксис, що дозволяє легко зрозуміти та модифікувати код`,
        "Slick Slider": `Slick Slider - це легка, гнучка та потужна бібліотека для створення слайдерів в веб-додатках. Вона надає різноманітні опції та можливості для керування та поведінкою слайдера.
Переваги використання слайдерів: 
Візуальна привабливість 
Збільшення участі користувачів
Адаптивність`
      }
    }
  ]
};