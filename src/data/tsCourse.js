export const typescriptCourseData = {
  title: "Основи TypeScript",
  description: "Вивчіть TypeScript від основ до просунутих концепцій. Комплексний курс, який навчить вас створювати типобезпечні та масштабовані JavaScript додатки.",
  level: "Від початкового до просунутого",
  duration: "~12 годин",
  prerequisites: "JavaScript ES6+, основи програмування",
  certificate: "Доступний після завершення",
  topics: [
    {
      id: 1,
      title: "Введення в TypeScript",
      difficulty: "Початковий",
      duration: "30 хв",
      completed: true,
      description: "Дізнайтеся, що таке TypeScript, його переваги та як почати з ним працювати.",
      learningPoints: [
        "Що таке TypeScript та навіщо він потрібен",
        "Статична типізація vs динамічна",
        "Виведення типів (type inference)",
        "Налаштування середовища розробки",
        "Компіляція TypeScript в JavaScript"
      ],
      theory: {
        "Що таке TypeScript": "TypeScript - це мова програмування, яка є надмножиною JavaScript. Основна ідея полягає в додаванні статичної типізації до JavaScript. Тобто, перевіряє типи під час компіляції, а не під час виконання, як JavaScript. Розроблений Microsoft, TypeScript компілюється в чистий JavaScript.",
        "Статична типізація": "TypeScript дозволяє оголошувати типи змінних заздалегідь, на відміну від JavaScript. Це допомагає виявляти помилки на етапі розробки, покращує читабельність коду та надає кращу підтримку інструментів розробки.",
        "Виведення типів": "TypeScript може автоматично визначати тип змінної на основі присвоєного їй значення. Це означає, що не завжди потрібно явно вказувати типи - TypeScript може їх вивести самостійно.",
        "Переваги TypeScript": "Раннє виявлення помилок, краща підтримка IDE (автодоповнення, рефакторинг), покращена читабельність коду, легше підтримувати великі проекти, сумісність з існуючим JavaScript кодом.",
        "Компіляція": "TypeScript компілюється в JavaScript за допомогою компілятора tsc. Можна налаштувати різні версії JavaScript (ES5, ES6, ES2020 тощо) та різні модульні системи."
      }
    },
    {
      id: 2,
      title: "Примітивні типи даних",
      difficulty: "Початковий",
      duration: "35 хв",
      completed: false,
      description: "Вивчіть основні типи даних у TypeScript та як з ними працювати.",
      learningPoints: [
        "Числові типи (number, bigint)",
        "Текстові типи (string)",
        "Логічний тип (boolean)",
        "Типи null та undefined",
        "Символи (symbol)",
        "Масиви та кортежі (tuple)"
      ],
      theory: {
        "Числові типи": "number - для всіх чисел (цілих та з плаваючою точкою). bigint - для великих цілих чисел, які перевищують межі number. TypeScript автоматично визначає тип числа на основі значення.",
        "Текстові дані": "string - для текстових даних. Підтримує звичайні рядки, шаблонні рядки (template literals) та всі методи JavaScript для роботи з рядками.",
        "Логічний тип": "boolean - для логічних значень true або false. Використовується в умовних конструкціях та логічних операціях.",
        "Відсутність значення": "null - явна відсутність значення. undefined - значення, яке ще не було присвоєно. TypeScript має спеціальні налаштування для роботи з цими типами.",
        "Символи": "symbol - унікальний ідентифікатор. Кожен символ є унікальним, навіть якщо створений з однаковим описом. Використовується для створення унікальних ключів об'єктів.",
        "Масиви": "array - масив елементів одного типу. Можна оголошувати як Type[] або Array<Type>. TypeScript перевіряє, що всі елементи масиву відповідають зазначеному типу.",
        "Кортежі": "tuple - масив фіксованої довжини з елементами різних типів. Дозволяє точно визначити типи елементів на кожній позиції."
      }
    },
    {
      id: 3,
      title: "Спеціальні типи TypeScript",
      difficulty: "Початковий",
      duration: "40 хв",
      completed: false,
      description: "Дізнайтеся про спеціальні типи TypeScript: any, unknown, void, never.",
      learningPoints: [
        "Тип any та його використання",
        "Unknown як безпечна альтернатива any",
        "Void для функцій без повернення",
        "Never для неможливих значень",
        "Коли використовувати кожен тип"
      ],
      theory: {
        "Тип any": "Тип any відключає перевірку типів для змінної. Використовується зазвичай при міграції з JavaScript або роботі з динамічним контентом. Слід уникати його використання, оскільки він нівелює переваги TypeScript.",
        "Тип unknown": "Більш безпечна альтернатива any. Змінна типу unknown може містити будь-яке значення, але перед використанням потрібно перевірити її тип. Це забезпечує типобезпеку при роботі з невідомими даними.",
        "Тип void": "Використовується для функцій, які нічого не повертають. Такі функції можуть повертати undefined або взагалі не мати оператора return.",
        "Тип never": "Представляє тип значень, які ніколи не з'являються. Використовується для функцій, які завжди викидають помилку або мають нескінченний цикл. Також використовується в умовних типах для позначення неможливих варіантів.",
        "Вибір правильного типу": "any - тільки при міграції або роботі з легасі кодом. unknown - для невідомих даних з подальшою перевіркою. void - для функцій без повернення значення. never - для функцій, які ніколи не завершуються нормально."
      }
    },
    {
      id: 4,
      title: "Об'єднання та перетин типів",
      difficulty: "Середній",
      duration: "45 хв",
      completed: false,
      description: "Навчіться створювати складні типи за допомогою об'єднання та перетину типів.",
      learningPoints: [
        "Union types (об'єднання типів)",
        "Intersection types (перетин типів)",
        "Type guards (захисники типів)",
        "Дискримінантні об'єднання",
        "Практичні приклади використання"
      ],
      theory: {
        "Об'єднання типів": "Об'єднання типів (union types) дозволяє змінній мати один з декількох можливих типів. Використовується оператор вертикальної риски (|). Корисно, коли функція може приймати різні типи даних або коли потрібно обробити кілька можливих варіантів.",
        "Перетин типів": "Перетин типів (intersection types) об'єднує декілька типів в один, використовуючи оператор амперсанд (&). Результуючий тип містить всі властивості всіх об'єднаних типів. Корисно для створення складних типів з простих.",
        "Захисники типів": "Type guards - це техніки для звуження типів у TypeScript. Дозволяють TypeScript зрозуміти, який саме тип має змінна в конкретному блоку коду. Включають typeof, instanceof, in оператори та користувацькі type guards.",
        "Дискримінантні об'єднання": "Спеціальний вид union types, де кожен тип має унікальну властивість (дискримінант), що дозволяє TypeScript точно визначити тип. Часто використовується в Redux actions та state machines.",
        "Практичне застосування": "Union types корисні для API відповідей, обробки різних форматів даних, опціональних параметрів. Intersection types - для міксинів, розширення інтерфейсів, комбінування поведінок."
      }
    },
    {
      id: 5,
      title: "Інтерфейси (Interfaces)",
      difficulty: "Середній",
      duration: "50 хв",
      completed: false,
      description: "Опануйте створення та використання інтерфейсів для опису структури об'єктів.",
      learningPoints: [
        "Основи створення інтерфейсів",
        "Опціональні властивості",
        "Readonly властивості",
        "Розширення інтерфейсів",
        "Індексні сигнатури"
      ],
      theory: {
        "Інтерфейси": "Інтерфейси описують структуру об'єктів. Вони визначають, які властивості повинен мати об'єкт, їх типи та чи є вони обов'язковими. Інтерфейси існують тільки на етапі компіляції та не генерують жодного JavaScript коду.",
        "Опціональні властивості": "Опціональні властивості позначаються знаком питання після назви властивості. Це означає, що властивість може бути присутньою або відсутньою в об'єкті. Корисно для конфігурацій та API параметрів.",
        "Readonly властивості": "Readonly властивості не можна змінювати після створення об'єкта. Позначаються ключовим словом readonly. Забезпечують незмінність даних та запобігають випадковим модифікаціям.",
        "Розширення інтерфейсів": "Інтерфейси можуть розширювати (наслідувати від) інші інтерфейси за допомогою ключового слова extends. Це дозволяє створювати ієрархії типів та перевикористовувати код.",
        "Індексні сигнатури": "Дозволяють описувати об'єкти з динамічними ключами, коли заздалегідь невідомо, які властивості будуть присутні. Корисно для словників, карт та динамічних об'єктів.",
        "Декларація злиття": "TypeScript може автоматично об'єднувати кілька декларацій одного інтерфейсу в один. Це корисно для розширення існуючих бібліотек та модульної архітектури."
      }
    },
    {
      id: 6,
      title: "Типи (Type Aliases)",
      difficulty: "Середній",
      duration: "45 хв",
      completed: false,
      description: "Вивчіть створення власних типів та їх відмінності від інтерфейсів.",
      learningPoints: [
        "Створення псевдонімів типів",
        "Відмінності між type та interface",
        "Умовні типи",
        "Mapped types",
        "Template literal types"
      ],
      theory: {
        "Псевдоніми типів": "Типи схожі на інтерфейси, але мають більше можливостей. Вони можуть описувати не тільки структуру об'єктів, але й об'єднання типів, примітивні типи, функції тощо. Створюються за допомогою ключового слова type.",
        "Type vs Interface": "Interface можна розширювати та об'єднувати, краще для об'єктів. Type більш гнучкий, може описувати union types, computed properties, але не може бути розширений. Interface краще для публічних API, type - для складних трансформацій.",
        "Умовні типи": "Conditional types дозволяють створювати типи, які залежать від умов. Використовують тернарний оператор для типів. Корисні для створення утилітних типів та складної логіки типізації.",
        "Mapped types": "Дозволяють створювати нові типи шляхом трансформації існуючих. Перебирають ключі типу та застосовують до них трансформації. Основа для багатьох утилітних типів TypeScript.",
        "Template literal types": "Дозволяють створювати типи на основі template literals. Корисні для створення строго типізованих рядків, CSS властивостей, API endpoints.",
        "Recursive types": "TypeScript підтримує рекурсивні типи для опису структур даних як дерева, вкладені об'єкти тощо."
      }
    },
    {
      id: 7,
      title: "Generics (Узагальнені типи)",
      difficulty: "Просунутий",
      duration: "60 хв",
      completed: false,
      description: "Освойте потужну систему Generics для створення перевикористовуваних типів.",
      learningPoints: [
        "Основи Generics",
        "Параметри типу та обмеження",
        "Узагальнені функції та класи",
        "Умовні типи з Generics",
        "Variance та covariance"
      ],
      theory: {
        "Generics": "Generics дозволяють створювати компоненти, які працюють з різними типами, зберігаючи інформацію про тип. Це робить код більш перевикористовуваним та типобезпечним. Замість жорсткого зазначення типу, використовуються параметри типу.",
        "Параметри типу": "Параметри типу позначаються як T, U, V або більш описові назви. Це змінні типи, які заповнюються конкретними типами при використанні. Можуть мати значення за замовчуванням та обмеження.",
        "Обмеження типів": "Constraints дозволяють обмежити, які типи можуть бути передані як параметри. Використовуючи extends ключове слово, можна вказати, що тип повинен розширювати певний інтерфейс або тип.",
        "Узагальнені функції": "Функції можуть приймати параметри типу та використовувати їх для типізації параметрів та повернення. Це дозволяє створювати функції, які працюють з різними типами безпечно.",
        "Узагальнені класи": "Класи можуть мати параметри типу, що дозволяє створювати типобезпечні контейнери, колекції та інші структури даних.",
        "Умовні типи": "Поєднання Generics з умовними типами дозволяє створювати складну логіку типізації, яка залежить від конкретних типів.",
        "Variance": "Розуміння коваріантності та контраваріантності важливе для правильного використання Generics у складних сценаріях."
      }
    },
    {
      id: 8,
      title: "Класи в TypeScript",
      difficulty: "Середній",
      duration: "55 хв",
      completed: false,
      description: "Дізнайтеся про розширені можливості класів TypeScript та модифікатори доступу.",
      learningPoints: [
        "Модифікатори доступу (public, private, protected)",
        "Readonly властивості",
        "Статичні члени класу",
        "Геттери та сеттери",
        "Наслідування та поліморфізм"
      ],
      theory: {
        "Класи в TypeScript": "TypeScript розширює можливості класів JavaScript, додаючи статичну типізацію та додаткові функції. Всі JavaScript класи є валідними TypeScript класами.",
        "Модифікатори доступу": "public - доступний всюди (за замовчуванням). private - доступний тільки в межах класу. protected - доступний в класі та його нащадках. Ці модифікатори існують тільки на етапі компіляції.",
        "Readonly властивості": "Readonly властивості можна встановити тільки в конструкторі або при оголошенні. Після ініціалізації їх не можна змінювати. Забезпечують незмінність даних.",
        "Статичні члени": "Статичні члени - це властивості та методи, які належать класу, а не його екземплярам. Доступні через ім'я класу без створення екземпляра.",
        "Геттери та сеттери": "Accessor properties дозволяють контролювати доступ до властивостей класу. Можна додати логіку валідації, логування або обчислення при отриманні/встановленні значення.",
        "Наслідування": "TypeScript підтримує одиничне наслідування класів. Дочірні класи можуть перевизначати методи батьківського класу та додавати нову функціональність.",
        "Абстракція": "TypeScript підтримує реалізацію інтерфейсів класами, що забезпечує дотримання контрактів."
      }
    },
    {
      id: 9,
      title: "Абстрактні класи та поліморфізм",
      difficulty: "Просунутий",
      duration: "50 хв",
      completed: false,
      description: "Вивчіть абстрактні класи та принципи об'єктно-орієнтованого програмування.",
      learningPoints: [
        "Абстрактні класи та методи",
        "Відмінності від інтерфейсів",
        "Поліморфізм у TypeScript",
        "Композиція vs наслідування",
        "Принципи SOLID"
      ],
      theory: {
        "Абстрактні класи": "Абстрактні класи - це класи, які не можна інстанціювати напряму. Вони слугують базою для інших класів та можуть містити абстрактні методи, які повинні бути реалізовані в дочірніх класах. Позначаються ключовим словом abstract.",
        "Абстрактні методи": "Абстрактні методи оголошуються без реалізації в абстрактному класі. Всі дочірні класи повинні надати реалізацію цих методів. Це забезпечує контракт, який повинні дотримуватись нащадки.",
        "Абстрактні класи vs Інтерфейси": "Абстрактні класи можуть містити реалізацію методів, конструктори та приватні члени. Інтерфейси описують тільки контракт. Клас може реалізовувати кілька інтерфейсів, але наслідувати тільки один абстрактний клас.",
        "Поліморфізм": "Поліморфізм дозволяє об'єктам різних типів реагувати на однакові повідомлення по-різному. TypeScript підтримує поліморфізм через наслідування та реалізацію інтерфейсів.",
        "Композиція": "Альтернатива наслідуванню, де об'єкт містить інші об'єкти та делегує їм частину своєї функціональності. Часто кращий вибір ніж наслідування для складних систем.",
        "Принципи SOLID": "Набір принципів об'єктно-орієнтованого дизайну: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion. TypeScript допомагає їх дотримуватись."
      }
    },
    {
      id: 10,
      title: "Енуми (Enumerations)",
      difficulty: "Середній",
      duration: "40 хв",
      completed: false,
      description: "Навчіться використовувати енуми для створення іменованих констант.",
      learningPoints: [
        "Числові енуми",
        "Рядкові енуми",
        "Гетерогенні енуми",
        "Const енуми",
        "Reverse mapping"
      ],
      theory: {
        "Енуми": "Енуми дозволяють створювати іменовані константи. Це зручний спосіб організації пов'язаних значень під одним іменем. TypeScript підтримує кілька видів енумів.",
        "Числові енуми": "За замовчуванням значення починаються з 0 та автоматично збільшуються. Можна явно встановити початкове значення або будь-яке конкретне значення. Підтримують зворотне відображення (reverse mapping).",
        "Рядкові енуми": "Кожне значення повинно бути явно ініціалізоване рядком. Не підтримують автоінкремент, але більш читабельні та безпечні. Кожне значення має бути унікальним.",
        "Гетерогенні енуми": "Змішують числові та рядкові значення в одному енумі. Не рекомендується використовувати, оскільки може призвести до плутанини та помилок.",
        "Const енуми": "Енуми, позначені як const, повністю видаляються під час компіляції для кращої продуктивності. Значення замінюються інлайн константами.",
        "Обчислювані значення": "Енуми можуть містити обчислювані значення, але всі наступні значення повинні бути явно ініціалізовані.",
        "Використання": "Енуми корисні для статусів, режимів роботи, типів подій, опцій конфігурації та інших випадків, де потрібен обмежений набір значень."
      }
    },
    {
      id: 11,
      title: "Утилітні типи",
      difficulty: "Просунутий",
      duration: "55 хв",
      completed: false,
      description: "Освойте вбудовані утилітні типи TypeScript для трансформації існуючих типів.",
      learningPoints: [
        "Часткові та обов'язкові типи (Partial, Required)",
        "Селекція властивостей (Pick, Omit)",
        "Трансформація типів (Record, Exclude, Extract)",
        "Робота з null та undefined (NonNullable)",
        "Створення власних утилітних типів"
      ],
      theory: {
        "Утилітні типи": "TypeScript надає набір вбудованих утилітних типів для трансформації існуючих типів. Вони дозволяють створювати нові типи на основі існуючих без дублювання коду.",
        "Partial та Required": "Partial<T> - робить всі властивості типу T опціональними. Корисно для часткових оновлень об'єктів. Required<T> - робить всі властивості обов'язковими, навіть якщо вони були опціональними.",
        "Readonly": "Readonly<T> - робить всі властивості тільки для читання. Забезпечує незмінність об'єктів на рівні типів.",
        "Pick та Omit": "Pick<T, K> - вибирає тільки вказані властивості K з типу T. Omit<T, K> - виключає вказані властивості K з типу T. Корисні для створення підмножин типів.",
        "Record": "Record<K, T> - створює тип з ключами K та значеннями T. Корисний для створення словників та карт з типізованими ключами та значеннями.",
        "Exclude та Extract": "Exclude<T, U> - виключає типи U з об'єднання T. Extract<T, U> - витягує тільки ті типи з T, які є частиною U.",
        "NonNullable": "NonNullable<T> - виключає null та undefined з типу T. Корисний для гарантування того, що значення не є null або undefined.",
        "Власні утилітні типи": "Можна створювати власні утилітні типи, комбінуючи вбудовані типи та використовуючи advanced type features."
      }
    },
    {
      id: 12,
      title: "Декоратори та метапрограмування",
      difficulty: "Просунутий",
      duration: "50 хв",
      completed: false,
      description: "Дізнайтеся про декоратори як спосіб метапрограмування в TypeScript.",
      learningPoints: [
        "Основи декораторів",
        "Декоратори класів та методів",
        "Декоратори властивостей та параметрів",
        "Metadata API",
        "Практичні приклади використання"
      ],
      theory: {
        "Декоратори": "Декоратори - експериментальна функція, яка дозволяє додавати метадані та змінювати поведінку класів, методів, властивостей та параметрів. Вони надають декларативний спосіб модифікації коду.",
        "Типи декораторів": "Декоратори класів - застосовуються до всього класу. Декоратори методів - модифікують поведінку методів. Декоратори властивостей - додають метадані до властивостей. Декоратори параметрів - працюють з параметрами методів.",
        "Фабрики декораторів": "Функції, які повертають декоратори. Дозволяють створювати конфігуровані декоратори з параметрами. Корисні для створення гнучких та перевикористовуваних декораторів.",
        "Metadata API": "TypeScript підтримує Reflect Metadata API для роботи з метаданими. Дозволяє зберігати та отримувати довільні метадані про типи, методи та властивості.",
        "Використання в фреймворках": "Декоратори широко використовуються в Angular (для компонентів, сервісів), NestJS (для контролерів, middleware), TypeORM (для ентіті), та інших фреймворках.",
        "Експериментальний статус": "Декоратори все ще експериментальна функція. Потрібно увімкнути experimentalDecorators в tsconfig.json. Синтаксис може змінитись у майбутніх версіях.",
        "Альтернативи": "Можна досягти схожої функціональності використовуючи функції вищого порядку, композицію та інші патерни без декораторів."
      }
    },
    {
      id: 13,
      title: "Модулі та простори імен",
      difficulty: "Середній",
      duration: "45 хв",
      completed: false,
      description: "Навчіться організовувати код за допомогою модулів та просторів імен.",
      learningPoints: [
        "ES6 модулі в TypeScript",
        "Експорт та імпорт",
        "Namespaces (простори імен)",
        "Модульні системи (CommonJS, AMD, UMD)",
        "Декларації модулів"
      ],
      theory: {
        "Модулі в TypeScript": "TypeScript повністю підтримує ES6 модулі. Будь-який файл з експортом або імпортом вважається модулем. Модулі мають власну область видимості.",
        "Експорт та імпорт": "Named exports - експорт конкретних значень з іменами. Default exports - експорт одного головного значення. Re-exports - реекспорт з інших модулів. TypeScript підтримує всі види ES6 імпорту/експорту.",
        "Namespaces": "Простори імен - це спосіб організації коду в TypeScript. Вони створюють логічні групи пов'язаної функціональності. Менш використовуються в сучасному TypeScript на користь модулів.",
        "Модульні системи": "TypeScript може компілюватись в різні модульні системи: CommonJS (Node.js), AMD (RequireJS), UMD (універсальні), ES6 modules. Вибір залежить від цільової платформи.",
        "Декларації модулів": "Ambient modules дозволяють описувати зовнішні модулі, які не написані на TypeScript. Module augmentation дозволяє розширювати існуючі модулі.",
        "Розв'язання модулів": "TypeScript має складну систему розв'язання модулів. Підтримує різні стратегії: node, classic. Можна налаштувати через baseUrl, paths, та інші опції.",
        "Triple-slash директиви": "Спеціальні коментарі для надання інструкцій компілятору про залежності файлів та типів."
      }
    },
    {
      id: 14,
      title: "TypeScript з React",
      difficulty: "Просунутий",
      duration: "60 хв",
      completed: false,
      description: "Дізнайтеся, як використовувати TypeScript в React проектах.",
      learningPoints: [
        "Типізація React компонентів",
        "Props та State типи",
        "Хуки в TypeScript",
        "Event handling та refs",
        "Higher-Order Components та Render Props"
      ],
      theory: {
        "React з TypeScript": "TypeScript значно покращує розробку React додатків, надаючи типобезпеку для компонентів, пропсів та стану. Допомагає виявляти помилки на етапі розробки.",
        "Типізація компонентів": "Функціональні компоненти типізуються як React.FC або просто як функції, що повертають JSX.Element. Класові компоненти розширюють React.Component з типізованими props та state.",
        "Props типи": "Props типізуються через інтерфейси або типи. Можна використовувати опціональні властивості, значення за замовчуванням та складні типи. Children мають спеціальний тип React.ReactNode.",
        "Хуки в TypeScript": "useState, useEffect та інші хуки можуть бути типізованими. TypeScript часто може вивести типи автоматично, але іноді потрібно явно вказувати типи, особливо для початкових значень.",
        "Обробка подій": "React події мають специфічні типи: MouseEvent, ChangeEvent, FormEvent тощо. TypeScript забезпечує типобезпеку для event handlers.",
        "Refs та DOM": "useRef хук типізується залежно від того, що зберігається. Для DOM елементів використовуються специфічні типи як HTMLInputElement, HTMLDivElement.",
        "Просунуті патерни": "HOC, Render Props, Context API мають специфічні патерни типізації в TypeScript. Generics часто використовуються для створення перевикористовуваних компонентів."
      }
    },
    {
      id: 15,
      title: "Налаштування та найкращі практики",
      difficulty: "Просунутий",
      duration: "55 хв",
      completed: false,
      description: "Освойте налаштування TypeScript проектів та найкращі практики розробки.",
      learningPoints: [
        "Конфігурація tsconfig.json",
        "Найкращі практики типізації",
        "Лінтінг та форматування",
        "Налагодження TypeScript",
        "Продуктивність та оптимізація"
      ],
      theory: {
        "Конфігураація проекту": "tsconfig.json є центральним файлом конфігурації TypeScript проекту. Визначає опції компіляції, включені файли, target ES версію та багато інших налаштувань.",
        "Ключові опції": "target - версія ECMAScript для виводу. module - модульна система. strict - увімкнення всіх строгих перевірок. lib - бібліотеки, які включити. outDir - папка для скомпільованих файлів.",
        "Найкращі практики": "Використовуйте strict mode. Уникайте any, використовуйте unknown. Надавайте перевагу type guards над type assertions. Використовуйте readonly для незмінних даних. Створюйте маленькі, сфокусовані типи.",
        "Лінтінг": "ESLint з @typescript-eslint/parser надає правила специфічні для TypeScript. Prettier для форматування коду. Налаштування едіторів для автоматичного форматування та виправлення.",
        "Налагодження": "Source maps для налагодження в браузері. TypeScript підтримка в IDE. Використання breakpoints в TypeScript коді. Аналіз типів та помилок компіляції.",
        "Продуктивність": "Incremental compilation для швидших збірок. Project references для великих проектів. Lazy типізація для покращення часу завантаження IDE. Оптимізація імпортів.",
        "Міграція з JavaScript": "Поступова міграція - додавання файлів .ts по одному. Використання @ts-check для перевірки JS файлів. Створення .d.ts файлів для типізації існуючого коду.",
        "Інструменти екосистеми": "ts-node для виконання TypeScript безпосередньо. webpack/rollup налаштування. Jest конфігурація для тестування TypeScript."
      }
    }
  ]
};